<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张飞的技术博客</title>
  <subtitle>一枚专注与移动开发的IT文艺青年</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="zhangfei.tk/"/>
  <updated>2016-03-23T05:05:28.000Z</updated>
  <id>zhangfei.tk/</id>
  
  <author>
    <name>小飞</name>
    <email>zhangfeidev@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊聊iOS开发中的单元测试</title>
    <link href="zhangfei.tk/2016/01/10/%E8%81%8A%E8%81%8AiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>zhangfei.tk/2016/01/10/聊聊iOS开发中的单元测试/</id>
    <published>2016-01-10T03:11:11.000Z</published>
    <updated>2016-03-23T05:05:28.000Z</updated>
    
    <content type="html">&lt;p&gt;看到文章标题的时候，你也许会问，测试不是测试妹子干的事吗？的确，测试妹子能帮助我们测试出软件的很多问题（不符合业务的问题）,但是代码的测试还得靠我们自己啊。团队Leader在开会时一直强调要打造一支不依靠测试团队的团队，因此，代码自测也变成了一个项目重要的一环。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;是的，今天我要聊的就是我们程序员对自己代码的测试，而不是测试妹子的测试。在iOS开发中我们用单元测试来保证我们的代码可靠性，什么是单元测试，请看在维基百科上的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机编程中，&lt;strong&gt;单元测试&lt;/strong&gt;（英语：Unit Testing）又称为&lt;strong&gt;模块测试&lt;/strong&gt;, 是针对程序模块的最小单位来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。   –  维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了单元测试以后，我们就没必要为了测试某个小模块去编译我们的程序，然后去等待模拟器启动然后到你需要验证的模块去。这样做也是可以的啦！可是，你的项目很大，编译等老半天，你的电脑没那么快，那就够你等的了。我还记得我工作的第一个公司，给我用的是一个性能堪忧的Mac mini，每次修改代码后&lt;code&gt;Command + R&lt;/code&gt;后都得等上一分多，简直不能忍受啊！是的，我没能忍受，没过多久我就离职了。扯淡这么半天，就是为了说明单元测试能节约我们的时间，提高开发效率，对于项目越大的效果越明显。&lt;/p&gt;
&lt;h3 id=&quot;XCTest&quot;&gt;&lt;a href=&quot;#XCTest&quot; class=&quot;headerlink&quot; title=&quot;XCTest&quot;&gt;&lt;/a&gt;XCTest&lt;/h3&gt;&lt;p&gt;XCode4.x时代Xcode集成的是&lt;strong&gt;OCUnit&lt;/strong&gt;，到了XCode5.x时代就升级为了&lt;strong&gt;XCTest&lt;/strong&gt;,并且到了XCode7时代还有了进行UI测试的能力。除了官方自带的，还有一些比较出名的第三方的测试框架，如：&lt;code&gt;GHUnit&lt;/code&gt;,&lt;code&gt;KiWi&lt;/code&gt;，&lt;code&gt;OCMock&lt;/code&gt;,&lt;code&gt;Specta&lt;/code&gt;等,当然本文不讨论这些第三方框架。怎么知道我们的项目有没有加上单元测试，用Xcode打开你的项目，看文件导航栏有没有类似下图的两个文件夹（TestDemo是工程名）。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/cfaa8811jw1f24tb8t8uhj207502xmx7.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;其实在我们新建工程的时候就可以为我们的工程选择是否带上单元测试，如下图：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/cfaa8811jw1f24t9w4630j20l80fcq4l.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如果你的项目没有上面说的两个文件，你可以通过新建一个Target的方式添加，如下图：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/cfaa8811jw1f24tbmvcuij20ft06jq4f.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在test下选择你项目没有的便可：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/cfaa8811jw1f24ta59qojj20l80fctav.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在这2个文件夹目录下分别都有2个文件，一个&lt;code&gt;.m&lt;/code&gt;文件和一个&lt;code&gt;plist&lt;/code&gt;文件。并且&lt;code&gt;.m&lt;/code&gt;文件有4个方法，如下图：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1f24t9xer0ij20v40hkq6q.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;项目名+Test&lt;/code&gt;的&lt;code&gt;.m&lt;/code&gt;文件里面默认有4个方法，这个文件里面主要做一些逻辑的测试。&lt;code&gt;项目名+UITest&lt;/code&gt;的&lt;code&gt;.m&lt;/code&gt;文件里默认有3个方法。这个文件里面主要做一些UI的测试。说了这么半天，该如何写单元测试呢？在讲解如何写测试方法前，先说说默认的方法是干什么的吧！&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//TestDemoTest.m&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setUp &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; setUp];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//每个test方法执行前调用，在这个测试用例里进行一些通用的初始化工作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Put setup code here. This method is called before the invocation of each test method in the class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)tearDown &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Put teardown code here. This method is called after the invocation of each test method in the class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; tearDown];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//每个test方法执行后调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)testExample &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//测试方法样例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// This is an example of a functional test case.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Use XCTAssert and related functions to verify your tests produce the correct results.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)testPerformanceExample &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//这个方法主要是做性能测试的，所谓性能测试，主要就是评估一段代码的运行时间。该方法就是性能测试方法的样例。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// This is an example of a performance test case.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; measureBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Put the code you want to measure the time of here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试用例方法非常简单，从&lt;code&gt;testExample&lt;/code&gt;这个方法我们大概知道怎么写了吧！方法名只需要以&lt;code&gt;test&lt;/code&gt;开头，是的，就是这么简单。现在我们模拟登录这个功能来写一个登录模块的测试用例吧，Demo代码在&lt;a href=&quot;https://github.com/zhangfeidev/TestingDemo.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;,在&lt;code&gt;User&lt;/code&gt;这个模型类里面一个方法叫&lt;code&gt;isChinese&lt;/code&gt;的，是用来判断字符串里面是否有中文的。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *userName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *passWord;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  判断字符串中是否有中文&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)isChinese:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们通过Xcode的&lt;code&gt;File&lt;/code&gt;-&amp;gt;&lt;code&gt;New&lt;/code&gt;-&amp;gt;&lt;code&gt;File&lt;/code&gt;-&amp;gt;&lt;code&gt;Source&lt;/code&gt;选择&lt;code&gt;Unit Test Case Class&lt;/code&gt;来新建一个&lt;code&gt;UserTests&lt;/code&gt;,注意要继承&lt;code&gt;XCTestCase&lt;/code&gt;类。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/cfaa8811jw1f24t9r3l83j20l80fct9i.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接下来我们为&lt;code&gt;User&lt;/code&gt;类写一个测试&lt;code&gt;isChinese&lt;/code&gt;方法的测试方法，叫做&lt;code&gt;testIsChinese&lt;/code&gt;,测试用例具体如下：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/cfaa8811jw1f24t9sx1pkj20yg0jg0vd.jpg&quot; alt=&quot;UserTests.m&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;这样，你只要点击测试方法旁边的那个菱形的按钮就可以运行该测试方法啦！通过测试会变成绿色的对勾，失败会变成红色的叉叉。到这里测试用例你就会写了。也许你会在意那些断言，这样的断言有18个，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTFail&lt;/span&gt;(format…)  &lt;span class=&quot;comment&quot;&gt;//生成一个失败的测试；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertNil&lt;/span&gt;(a1, format...)  &lt;span class=&quot;comment&quot;&gt;//为空判断，a1为空时通过，反之不通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertNotNil&lt;/span&gt;(a1, format…) &lt;span class=&quot;comment&quot;&gt;//不为空判断，a1不为空时通过，反之不通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssert&lt;/span&gt;(expression, format...) &lt;span class=&quot;comment&quot;&gt;//当expression求值为TRUE时通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertTrue&lt;/span&gt;(expression, format...) &lt;span class=&quot;comment&quot;&gt;//当expression求值为TRUE时通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertFalse&lt;/span&gt;(expression, format...)  &lt;span class=&quot;comment&quot;&gt;//当expression求值为False时通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertEqualObjects&lt;/span&gt;(a1, a2, format...)  &lt;span class=&quot;comment&quot;&gt;//判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertNotEqualObjects&lt;/span&gt;(a1, a2, format...)  &lt;span class=&quot;comment&quot;&gt;//判断不等，[a1 isEqual:a2]值为False时通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertEqual&lt;/span&gt;(a1, a2, format...)  &lt;span class=&quot;comment&quot;&gt;//判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertNotEqual&lt;/span&gt;(a1, a2, format...)  &lt;span class=&quot;comment&quot;&gt;//判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertEqualWithAccuracy&lt;/span&gt;(a1, a2, accuracy, format...)  &lt;span class=&quot;comment&quot;&gt;//判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertNotEqualWithAccuracy&lt;/span&gt;(a1, a2, accuracy, format...)   &lt;span class=&quot;comment&quot;&gt;//判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertThrows&lt;/span&gt;(expression, format...)  &lt;span class=&quot;comment&quot;&gt;//异常测试，当expression发生异常时通过；反之不通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertThrowsSpecific&lt;/span&gt;(expression, specificException, format...)  &lt;span class=&quot;comment&quot;&gt;//异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertThrowsSpecificNamed&lt;/span&gt;(expression, specificException, exception_name, format...)  &lt;span class=&quot;comment&quot;&gt;//异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertNoThrow&lt;/span&gt;(expression, format…)  &lt;span class=&quot;comment&quot;&gt;//异常测试，当expression没有发生异常时通过测试；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertNoThrowSpecific&lt;/span&gt;(expression, specificException, format...)  &lt;span class=&quot;comment&quot;&gt;//异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertNoThrowSpecificNamed&lt;/span&gt;(expression, specificException, exception_name, format...)  &lt;span class=&quot;comment&quot;&gt;//异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;UI测试&quot;&gt;&lt;a href=&quot;#UI测试&quot; class=&quot;headerlink&quot; title=&quot;UI测试&quot;&gt;&lt;/a&gt;UI测试&lt;/h3&gt;&lt;p&gt;用代码写UI测试比较麻烦，但是苹果在Xcode中为我们提供了录制的功能。录制是怎么一回事呢？当你打开时这个功能时，测试代码会随着你在设备或模拟器上操作自动创建。这么一来就省事多了。现在，我们在&lt;code&gt;TestDemoUITests.m&lt;/code&gt;文件中写一个方法&lt;code&gt;testLogin&lt;/code&gt;作为测试登录流程操作的UI测试方法。然后把光标放在方法体内，然后点击红色的那个录制按钮，如下：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/cfaa8811jw1f24ta68xk4j20yg0o3431.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;当你点击了录制后，程序就会自动启动，这时候你在程序的所有操作都会生成想用的代码在你所选择的方法体内。我录制了一个GIF，你可以看一下，非常的好用：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/cfaa8811gw1f24tntkir8g20hs0a0x6r.gif&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接下来我们看看里面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//XCUIApplication 这是应用的代理，他能够把你的应用启动起来，并且每次都在一个新进程中。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCUIApplication&lt;/span&gt; *app = [[&lt;span class=&quot;built_in&quot;&gt;XCUIApplication&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//XCUIElement 这是 UI 元素的代理。元素都有类型和唯一标识。可以结合使用来找到元素在哪里，如当前界面上的一个输入框&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCUIElement&lt;/span&gt; *usernameTextField = app.textFields[&lt;span class=&quot;string&quot;&gt;@&quot;username:&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[usernameTextField tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[usernameTextField typeText:&lt;span class=&quot;string&quot;&gt;@&quot;xiaofei&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCUIElement&lt;/span&gt; *passwordTextField = app.textFields[&lt;span class=&quot;string&quot;&gt;@&quot;password:&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[passwordTextField tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[passwordTextField tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[passwordTextField typeText:&lt;span class=&quot;string&quot;&gt;@&quot;12345&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[[[[[[app childrenMatchingType:&lt;span class=&quot;built_in&quot;&gt;XCUIElementTypeWindow&lt;/span&gt;] elementBoundByIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] childrenMatchingType:&lt;span class=&quot;built_in&quot;&gt;XCUIElementTypeOther&lt;/span&gt;].element childrenMatchingType:&lt;span class=&quot;built_in&quot;&gt;XCUIElementTypeOther&lt;/span&gt;].element childrenMatchingType:&lt;span class=&quot;built_in&quot;&gt;XCUIElementTypeOther&lt;/span&gt;].element childrenMatchingType:&lt;span class=&quot;built_in&quot;&gt;XCUIElementTypeOther&lt;/span&gt;].element tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[app.buttons[&lt;span class=&quot;string&quot;&gt;@&quot;login&quot;&lt;/span&gt;] tap];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有了这些代码，我们就可以对它进行一些处理了，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//XCUIApplication 这是应用的代理，他能够把你的应用启动起来，并且每次都在一个新进程中。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCUIApplication&lt;/span&gt; *app = [[&lt;span class=&quot;built_in&quot;&gt;XCUIApplication&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//XCUIElement 这是 UI 元素的代理。元素都有类型和唯一标识。可以结合使用来找到元素在哪里，如当前界面上的一个输入框&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCUIElement&lt;/span&gt; *usernameTextField = app.textFields[&lt;span class=&quot;string&quot;&gt;@&quot;username:&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[usernameTextField tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[usernameTextField typeText:&lt;span class=&quot;string&quot;&gt;@&quot;xiaofei&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCUIElement&lt;/span&gt; *passwordTextField = app.textFields[&lt;span class=&quot;string&quot;&gt;@&quot;password:&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[passwordTextField tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[passwordTextField tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[passwordTextField typeText:&lt;span class=&quot;string&quot;&gt;@&quot;12345&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[[[[[[app childrenMatchingType:&lt;span class=&quot;built_in&quot;&gt;XCUIElementTypeWindow&lt;/span&gt;] elementBoundByIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] childrenMatchingType:&lt;span class=&quot;built_in&quot;&gt;XCUIElementTypeOther&lt;/span&gt;].element childrenMatchingType:&lt;span class=&quot;built_in&quot;&gt;XCUIElementTypeOther&lt;/span&gt;].element childrenMatchingType:&lt;span class=&quot;built_in&quot;&gt;XCUIElementTypeOther&lt;/span&gt;].element childrenMatchingType:&lt;span class=&quot;built_in&quot;&gt;XCUIElementTypeOther&lt;/span&gt;].element tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[app.buttons[&lt;span class=&quot;string&quot;&gt;@&quot;login&quot;&lt;/span&gt;] tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//登录成功后的控制器的title为loginSuccess，只需判断控制器的title时候一样便可判断登录是否成功&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;XCTAssertEqualObjects&lt;/span&gt;(app.navigationBars.element.identifier, &lt;span class=&quot;string&quot;&gt;@&quot;loginSuccess&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你想一次跑完所有的测试方法，快捷键&lt;code&gt;cmd&lt;/code&gt;+&lt;code&gt;u&lt;/code&gt;即可。跑起来后的面板主要如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/cfaa8811jw1f24u0fgx6mj20yg0jjaes.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;这只是苹果官方集成在Xcode中的简单框架，优点就是简单，缺点也是简单。当然它的用法也绝非如此，有很多还待开发。苹果官方也有一个Demo，地址&lt;a href=&quot;https://developer.apple.com/library/prerelease/mac/samplecode/UnitTests/Introduction/Intro.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;看到文章标题的时候，你也许会问，测试不是测试妹子干的事吗？的确，测试妹子能帮助我们测试出软件的很多问题（不符合业务的问题）,但是代码的测试还得靠我们自己啊。团队Leader在开会时一直强调要打造一支不依靠测试团队的团队，因此，代码自测也变成了一个项目重要的一环。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Objective-C" scheme="zhangfei.tk/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>记2015</title>
    <link href="zhangfei.tk/2015/12/31/%E8%AE%B02015/"/>
    <id>zhangfei.tk/2015/12/31/记2015/</id>
    <published>2015-12-31T03:11:11.000Z</published>
    <updated>2016-03-03T07:35:24.000Z</updated>
    
    <content type="html">&lt;p&gt;一年就要过去，新的一年又将来临。眨眼间，一个年头就完了。这一年，我差不多结束了课堂的日子；这一年，我试着踏入真正的社会生活；这一年，从学校的闲散日子变成了朝九晚五的生活。跌跌撞撞，再过十几天就22了，也老大不小了，学着总结一下这一年。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;大三下学期，意味这是大学最后的课堂时间&quot;&gt;&lt;a href=&quot;#大三下学期，意味这是大学最后的课堂时间&quot; class=&quot;headerlink&quot; title=&quot;大三下学期，意味这是大学最后的课堂时间&quot;&gt;&lt;/a&gt;&lt;center&gt;大三下学期，意味这是大学最后的课堂时间&lt;/center&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;专业有一个非常好的政策，允许学习优秀和专业技能过硬的同学大四一年顶岗实习。这个政策非常值得点赞!但是这样也意味着就要和大学的课堂生活说拜拜了。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/cfaa8811jw1ezj4lo5t0gj21kw0w07ix.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;要离开校园，就必须的了结许多事。于是本该大四上的课，一下子提前了。留给我们的是满满的课表和许多的课设。&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/cfaa8811jw1ezjyc8jl56j20x718gncy.jpg&quot; alt=&quot;摄像课设，都是满满的回忆啊&quot;&gt;&lt;/center&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;在学生会带了三年，没做出什么了不起的事情，但是结识很多小伙伴。从部员到部长，一晃就是三年，说长不长，说短不短，从小学到高中，在社团学生会总有我的影子，成长了，也该告别了。&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/cfaa8811jw1ezjyc7iq8mj20qo0jr446.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;h4 id=&quot;五月份，去看看我的好兄弟&quot;&gt;&lt;a href=&quot;#五月份，去看看我的好兄弟&quot; class=&quot;headerlink&quot; title=&quot;五月份，去看看我的好兄弟&quot;&gt;&lt;/a&gt;&lt;center&gt;五月份，去看看我的好兄弟&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;从西南到东北，上学做的火车走遍了大半个中国。当初不知道怎么想的，跑到这么远的地方上大学。没想到的是高中的一哥们也跑到了这么远的地方。想着当初高考没考好，自己跑到网吧填的自愿，除了我之外谁都不知道我会填这里的志愿。没想到，好哥们也到了离我不远的北华大学念书。说来惭愧，来东北三年都没有去看过他，他倒是来看过我几次。在离开之前，怎么也得去看望一下这个在吉林松花江畔读大学的好哥们。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/cfaa8811jw1ezjyw0ecj0j21kw16hto4.jpg&quot; alt=&quot;松花江&quot;&gt;&lt;/center&gt;

&lt;h4 id=&quot;七月份，开始尝试北漂&quot;&gt;&lt;a href=&quot;#七月份，开始尝试北漂&quot; class=&quot;headerlink&quot; title=&quot;七月份，开始尝试北漂&quot;&gt;&lt;/a&gt;&lt;center&gt;七月份，开始尝试北漂&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;七月份，阳光正好，北京的天空还是蓝蓝的。在学长学姐的大力帮助下，开始了北漂之旅。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/cfaa8811jw1ezjz6pqm00j21kw16h7wh.jpg&quot; alt=&quot;开始帝都的生活了&quot;&gt;&lt;/center&gt;

&lt;h4 id=&quot;新的挑战，找工作&quot;&gt;&lt;a href=&quot;#新的挑战，找工作&quot; class=&quot;headerlink&quot; title=&quot;新的挑战，找工作&quot;&gt;&lt;/a&gt;&lt;center&gt;新的挑战，找工作&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;招聘网上的工作岗位倒是不少，可是过了2周，投出去的简历就像扔进大海的石头。这才体会到社会对文凭的偏见，要是可以从来，我会重来一次高考。说多了都是泪，也是废话。既来之，则安之。没有过不去的坎。半个月过去了，终于收到了第一份面试邀请。可是激动地我却在人生的第一次面试就遭到了重创。生活任然要继续，接着第二次，第三次。过了二十天左右，拿到了三家公司的实习生资格。遵循老师的教诲，来帝都是来学习的，只要养活自己就行了，于是选择了待遇最低的一家公司。在这里，我遇到了从小就崇拜的李开复老师。也遇到了一群朝气的同事和年轻的老板。就这样开始了我人生的第一份工作。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/cfaa8811jw1ezjyyvqb3pj20e20irdh5.jpg&quot; alt=&quot;第一份工作的地方，创新工场&quot;&gt;&lt;/center&gt;

&lt;h4 id=&quot;进京几个月，却住了三个地方&quot;&gt;&lt;a href=&quot;#进京几个月，却住了三个地方&quot; class=&quot;headerlink&quot; title=&quot;进京几个月，却住了三个地方&quot;&gt;&lt;/a&gt;&lt;center&gt;进京几个月，却住了三个地方&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;在好友的推荐下，把工作换到了京东，创新工场都是小团队，小团队有小团队的好。可是让我感觉不到提升，于是毅然的来到了京东。可是比较惨的是，京东在东南边。与我住的地方完全是对立的好不好，没办法，选择了搬家，从沙河搬到了亦庄。对于我这种刚出来的人来说，短时间内搬家是损失比较大的。都知道北京房价高，相对应的租房子的价格也不矮。没住满3个月，押金什么的就别想退了，于是乎，上班两个月的我又一分不剩。来到京东和好友在公司旁边合租了一间房，就算2人一个卧室一人都得一千多。哎，什么都别想了，活下去就行了。就这样在京东一直工作到了现在。在公司旁边住了三个月，由于种种原因，又搬到了旧宫。这下子算稳定了。稳定倒是稳定了，可是一不小心就到了年尾。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/cfaa8811jw1ezk00wg3osj20hs0qognt.jpg&quot; alt=&quot;成为京东的一份子&quot;&gt;&lt;/center&gt;

&lt;h4 id=&quot;展望一下明年&quot;&gt;&lt;a href=&quot;#展望一下明年&quot; class=&quot;headerlink&quot; title=&quot;展望一下明年&quot;&gt;&lt;/a&gt;&lt;center&gt;展望一下明年&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;年复一年，不能让时间停下脚步，就让我们去追赶吧！给明年一个目标，不要让自己随时间衰老自己的那颗心。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺利毕业&lt;/li&gt;
&lt;li&gt;加强专业技能修养&lt;/li&gt;
&lt;li&gt;有一份满意的装备&lt;/li&gt;
&lt;li&gt;找一份满意的工作&lt;/li&gt;
&lt;li&gt;让女友和他的家人放心我是个不错的小伙&lt;/li&gt;
&lt;li&gt;多回家看看父母和爷爷奶奶&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;h1&gt;最后，祝大家新年快乐！&lt;/h1&gt;&lt;/center&gt;

</content>
    
    <summary type="html">
    
      &lt;p&gt;一年就要过去，新的一年又将来临。眨眼间，一个年头就完了。这一年，我差不多结束了课堂的日子；这一年，我试着踏入真正的社会生活；这一年，从学校的闲散日子变成了朝九晚五的生活。跌跌撞撞，再过十几天就22了，也老大不小了，学着总结一下这一年。&lt;/p&gt;
    
    </summary>
    
      <category term="生活碎碎念" scheme="zhangfei.tk/categories/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="随笔" scheme="zhangfei.tk/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>读《苹果Cocoa编码规范》笔记</title>
    <link href="zhangfei.tk/2015/12/17/%E8%AF%BB%E3%80%8A%E8%8B%B9%E6%9E%9CCocoa%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>zhangfei.tk/2015/12/17/读《苹果Cocoa编码规范》笔记/</id>
    <published>2015-12-17T03:11:11.000Z</published>
    <updated>2016-03-23T05:06:16.000Z</updated>
    
    <content type="html">&lt;p&gt;为什么要有编码规范这么一说呢？你设想一下如果张三写代码一个风格，李四一个风格，当张三去看李四的时候他会极度的不舒服，反过来李四去看张三的代码的时候也会感觉非常的糟糕。所以他们两个人遵循同一个规则的时候，再去看对方的代码的时候就不会不适应，因此指定一个大家都遵循的代码编程风格就至关重要了。对于iOS开发，苹果官方就制定了一套编码规范。作为iOS开发者遵循苹果制定的编码规范写代码，那么在看苹果的官方代码的时候就觉得很轻松了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这点非常重要！！！没有重复三遍，但是依然是最重要的！！！如果你不是一开始就跟着项目走而是在中途或者是需要你维护一个别人留下的项目的时候。如果项目是经过几手，而且没有统一的命名风格，而且还没有注释。这时候你面对项目，你的内心是崩溃的。如果可以把写这些代码的揪出来，我保证你会把他打的不像人样！好的命名胜过N多的注释！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;命名的一般性原则&quot;&gt;&lt;a href=&quot;#命名的一般性原则&quot; class=&quot;headerlink&quot; title=&quot;命名的一般性原则&quot;&gt;&lt;/a&gt;命名的一般性原则&lt;/h3&gt;&lt;h4 id=&quot;清晰性&quot;&gt;&lt;a href=&quot;#清晰性&quot; class=&quot;headerlink&quot; title=&quot;清晰性&quot;&gt;&lt;/a&gt;清晰性&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;要清晰且简短，但是要注意不要因为简短放弃简短，清晰是首位。&lt;/li&gt;
&lt;li&gt;名称通常不缩写，即使名称很长也要拼写完全。（你有可能比较讨厌苹果那长长的方法名，但是你看到方法就知道是干嘛的，连文档都省了，因此OC也有自文档语言的美誉）。&lt;/li&gt;
&lt;li&gt;避免有歧义的命名。歧义是一个造成误会的罪魁祸首。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;一致性&quot;&gt;&lt;a href=&quot;#一致性&quot; class=&quot;headerlink&quot; title=&quot;一致性&quot;&gt;&lt;/a&gt;一致性&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;代码命名的一致性能带给阅读代码者非常的阅读体验，能让人一眼就看出这大概是什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;尽可能使用与Cocoa编程接口命名保持一致的名称。如果你不太确定某个命名的一致性,请浏览一下头文件或参考文档中的范例。&lt;/li&gt;
&lt;li&gt;在使用多态方法的类中,命名的一致性非常重要。在不同类中实现相同功能的方法应该具有相同的名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;不要自我指涉&quot;&gt;&lt;a href=&quot;#不要自我指涉&quot; class=&quot;headerlink&quot; title=&quot;不要自我指涉&quot;&gt;&lt;/a&gt;不要自我指涉&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;自我指涉的英文是：self-reference,如果你不明白什么是自我指涉，给你讲个故事吧。从前有座山，山上有座庙，庙里有个和尚，和尚说，从前有座山……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;首先名称不要自我指涉，看下面的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt;         &lt;span class=&quot;comment&quot;&gt;//okey&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSStringObject&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;//自我指涉&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;掩码(可使用位操作进行组合)和用作通知名称的常量不受该约定限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;前缀&quot;&gt;&lt;a href=&quot;#前缀&quot; class=&quot;headerlink&quot; title=&quot;前缀&quot;&gt;&lt;/a&gt;前缀&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;前缀不仅可以防止和苹果的命名发生冲突，而且也可以区分软件的功能范围，比如UIKit里面的都以UI开头，看到UI开头的类我们就能知道是UI相关的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;前缀有规定的格式。它由两到三个大写字符组成,不能使用下划线与子前缀。&lt;/li&gt;
&lt;li&gt;命名class,protocol,structure,函数,常量时使用前缀;命名成员方法时不使用前缀,因为方法已经在它所在类的命名空间种;同理,命名结构体字段时也不使用前缀。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;书写约定&quot;&gt;&lt;a href=&quot;#书写约定&quot; class=&quot;headerlink&quot; title=&quot;书写约定&quot;&gt;&lt;/a&gt;书写约定&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;书写约定能规范命名，不然你会看到其他语言的影子，比如以前写C++的你就会发现他会带一股浓浓的C++味道。OC也应该有OC的味道。来看看OC对于书写有哪些约定吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对于包含多个单词的名称,不要使用标点符号作为名称的一部分或作为分隔符(下划线,破折号等)。大写每个单词的首字符并将这些单词连续拼写在一起。并且要注意一下限制：&lt;ul&gt;
&lt;li&gt;方法名小写第一个单词的首字符,大写后续所有单词的首字符。方法名不使用前缀。&lt;/li&gt;
&lt;li&gt;函数名和常量名使用与其关联类相同的前缀,并且要大写前缀后面所有单词的首字符。&lt;/li&gt;
&lt;li&gt;避免使用下划线来表示名称的私有属性。苹果公司保留该方式的使用。如果第三方这样使用可能 会导致命名冲突,他们可能会在无意中用自己的方法覆盖掉已有的私有方法,这会导致严重的后 果。（苹果是不建议用私有变量的，这一点在用runtime解决一些问题的时候常常用到，因此得注意。在命名的时候不要把其他语言的习惯带到OC中）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;类与协议命名要注意的事儿&quot;&gt;&lt;a href=&quot;#类与协议命名要注意的事儿&quot; class=&quot;headerlink&quot; title=&quot;类与协议命名要注意的事儿&quot;&gt;&lt;/a&gt;类与协议命名要注意的事儿&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;类名应包含一个明确􏰁述该类(或类的对象)是什么或做什么的名词。类名要有合适的前缀。&lt;/li&gt;
&lt;li&gt;协议应该根据对方法的行为分组方式来命名。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于头文件&quot;&gt;&lt;a href=&quot;#关于头文件&quot; class=&quot;headerlink&quot; title=&quot;关于头文件&quot;&gt;&lt;/a&gt;关于头文件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;声明孤立的类或协议:将孤立的类或协议声明放置在单独的头文件中,该头文件名称与类或协议同名。&lt;/li&gt;
&lt;li&gt;声明相关联的类或协议:将相关联的声明(类,类别及协议) 放置在一个头文件中,该头文件名称与 主要的类/类别/协议的名字相同。&lt;/li&gt;
&lt;li&gt;包含框架头文件:每个框架应该包含一个与框架同名的头文件,该头文件包含该框架所有公开的头文 件。（写一个库的时候一般得这么干，你去看看苹果的库或者出名的苦，里面有一个和库同名的头文件，里面全是其他头文件的引用）。&lt;/li&gt;
&lt;li&gt;为已有框架中的某个类扩展 API:如果要在一个框架中声明属于另一个框架某个类的范畴类的方法, 该头文件的命名形式为:原类名+“Additions”。&lt;/li&gt;
&lt;li&gt;相关联的函数与数据类型:将相联的函数,常量,结构体以及其他数据类型放置到一个头文件中,并&lt;br&gt;￼以合适的名字命名。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于方法命名&quot;&gt;&lt;a href=&quot;#关于方法命名&quot; class=&quot;headerlink&quot; title=&quot;关于方法命名&quot;&gt;&lt;/a&gt;关于方法命名&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;除了上述要注意的，还有一些小的问题也需要注意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;表示对象行为的方法,名称以动词开头。&lt;/li&gt;
&lt;li&gt;名称中不要出现 do 或 does,因为这些助动词没什么实际意义。也不要在动词前使用副词或形容词修饰。&lt;/li&gt;
&lt;li&gt;如果方法返回方法接收者的某个属性,直接用属性名称命名。不要使用 get,除非是间接返回一个或 多个值。&lt;/li&gt;
&lt;li&gt;参数要用􏰀述该参数的关键字命名。&lt;/li&gt;
&lt;li&gt;参数前面的单词要能􏰀述该参数。&lt;/li&gt;
&lt;li&gt;不要使用and来连接用属性作参数关键字。一般不用and,除非满足下面这条。&lt;/li&gt;
&lt;li&gt;如果方法􏰀述两种独立的行为,使用and来串接它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于访问方法&quot;&gt;&lt;a href=&quot;#关于访问方法&quot; class=&quot;headerlink&quot; title=&quot;关于访问方法&quot;&gt;&lt;/a&gt;关于访问方法&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;访问方法就是我们常说的setter和getter方法。那么在写(或重写)访问方法的时候要注意些什么呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果属性是用名词􏰀述的,则命名格式为:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) setNoun:(type)aNoun;- (type) noun;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果属性是用形容词􏰀述的,则命名格式为:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) setAdjective:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)flag;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;) isAdjective;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果属性是用动词􏰀述的,则命名格式为:(动词要用现在时时态)&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) setVerbObject:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)flag;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;) verbObject;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;不要使用动词的过去分词形式作形容词使用.&lt;/li&gt;
&lt;li&gt;可以使用情态动词(can,should,will等)来􏰁高清晰性,但不要使用do或does.&lt;/li&gt;
&lt;li&gt;只有在方法需要间接返回多个值的情况下,才使用get.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于委托方法&quot;&gt;&lt;a href=&quot;#关于委托方法&quot; class=&quot;headerlink&quot; title=&quot;关于委托方法&quot;&gt;&lt;/a&gt;关于委托方法&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在开发中会经常用到代理设计模式，但是代理方法也是有一定的命名规则的。委托方法的这些规则也使用于&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;名称以标示发送消息的对象的类名开头,省略类名的前缀并小写类第一个字符。经常用的tabview的代理方法或者数据源方法都是tabview开头的。&lt;/li&gt;
&lt;li&gt;冒号紧跟在类名之后(随后的那个参数表示委派的对象)。该规则不适用于只有一个 sender 参数的 方法。&lt;/li&gt;
&lt;li&gt;面的那条规则也不适用于响应通知的方法。在这种情况下,方法的唯一参数表示通知对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) windowDidChangeScreen:(&lt;span class=&quot;built_in&quot;&gt;NSNotification&lt;/span&gt; *)notification;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;用于通知委托对象操作即将发生或已经发生的方法名中要使用did或will.&lt;/li&gt;
&lt;li&gt;用于询问委托对象可否执行某操作的方法名中可使用did或will,但最好使用should.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于集合方法&quot;&gt;&lt;a href=&quot;#关于集合方法&quot; class=&quot;headerlink&quot; title=&quot;关于集合方法&quot;&gt;&lt;/a&gt;关于集合方法&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;集合方法命名有如下一些限制和约定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果集合中的元素无序,返回 NSSet,而不是 NSArray。&lt;/li&gt;
&lt;li&gt;如果将元素插入指定位置的功能很重要,则需具备如下方法:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;集合方法的实现要考虑如下细节:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;集合类方法通常负责管理元素的所有者关系,在 add 或 insert 的实现代码里会 retain 元素,在 remove 的实现代码中会 release 元素.&lt;/li&gt;
&lt;li&gt;当被插入的对象需要持有指向集合对象的指针时,通常使用 set… 来命名其设置该指针的方法,且不 要 retain 集合对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于方法的参数&quot;&gt;&lt;a href=&quot;#关于方法的参数&quot; class=&quot;headerlink&quot; title=&quot;关于方法的参数&quot;&gt;&lt;/a&gt;关于方法的参数&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;第一条是最基本的，参数小写第一个单词首字母，大写后面单词的首字母。&lt;/li&gt;
&lt;li&gt;不要在参数名中使用 pointer 或 ptr,让参数的类型来说明它是指针。&lt;/li&gt;
&lt;li&gt;避免使用 one, two,…,作为参数名。这样的参数都不好意思用，鬼知道这代表什么。&lt;/li&gt;
&lt;li&gt;尽量不要缩写，多写几个字母又不会死人。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于私有方法&quot;&gt;&lt;a href=&quot;#关于私有方法&quot; class=&quot;headerlink&quot; title=&quot;关于私有方法&quot;&gt;&lt;/a&gt;关于私有方法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;不要使用下划线表示自己私有方法名称的前缀，Apple保留了这种做法。&lt;/li&gt;
&lt;li&gt;若要继承 Cocoa framework 中一个超大的类(如:NSView),并且想要使你的私有方法名称与基类 中的区别开来,你可以为你的私有方法名称添加你自己的前缀。这个前缀应该具有唯一性,如基于你 公司的名称,或工程的名称,并以“XX_”形式给出。比如你的工程名为”Byte Flogger”,那么就可以是 “BF_addObject:”。这一点在我的博文分析别人的开源库的时候就发现就有人这么做。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于函数的命名&quot;&gt;&lt;a href=&quot;#关于函数的命名&quot; class=&quot;headerlink&quot; title=&quot;关于函数的命名&quot;&gt;&lt;/a&gt;关于函数的命名&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在OC中是可以使用C函数的，所以这里的函数指的是C函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;函数命名与方法命名相似,但有两点不同:&lt;ul&gt;
&lt;li&gt;它们有前缀,其前缀与你使用的类和常量的前缀相同&lt;/li&gt;
&lt;li&gt;大写前缀后紧跟的第一个单词首字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大多数函数名称以动词开头,这个动词􏰀述该函数的行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实例变量与数据类型的命名&quot;&gt;&lt;a href=&quot;#实例变量与数据类型的命名&quot; class=&quot;headerlink&quot; title=&quot;实例变量与数据类型的命名&quot;&gt;&lt;/a&gt;实例变量与数据类型的命名&lt;/h3&gt;&lt;h4 id=&quot;实例变量&quot;&gt;&lt;a href=&quot;#实例变量&quot; class=&quot;headerlink&quot; title=&quot;实例变量&quot;&gt;&lt;/a&gt;实例变量&lt;/h4&gt;&lt;p&gt;在为类添加实例变量的时候需要注意以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免创建public变量&lt;/li&gt;
&lt;li&gt;使用@private,@protected显式限定实例变量的访问权限&lt;/li&gt;
&lt;li&gt;确保实例变量名简明扼要地􏰀述了它所代表的属性&lt;/li&gt;
&lt;li&gt;如果实例变量被设计为可被访问的,确保编写了访问方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;枚举常量&quot;&gt;&lt;a href=&quot;#枚举常量&quot; class=&quot;headerlink&quot; title=&quot;枚举常量&quot;&gt;&lt;/a&gt;枚举常量&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用枚举来定义一组相关的整数常量&lt;/li&gt;
&lt;li&gt;枚举常量与其typedef遵守函数命名规则&lt;/li&gt;
&lt;li&gt;位掩码常量可以使用不具名枚举&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;其他常量&quot;&gt;&lt;a href=&quot;#其他常量&quot; class=&quot;headerlink&quot; title=&quot;其他常量&quot;&gt;&lt;/a&gt;其他常量&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通常不使用 #define来创建常量。如上面所述,整数常量请使用枚举,浮点数常量请使用const&lt;/li&gt;
&lt;li&gt;使用大写字母来定义预处理编译宏。如:#ifdef DEBUG&lt;/li&gt;
&lt;li&gt;编译器定义的宏名首尾都有双下划线。如:&lt;strong&gt;MACH&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;为 notification 名及 dictionary key 定义字符串常量,从而能够利用编译器的拼写检查,减少书写错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;通知&quot;&gt;&lt;a href=&quot;#通知&quot; class=&quot;headerlink&quot; title=&quot;通知&quot;&gt;&lt;/a&gt;通知&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如果一个类有委托,那它的大部分通知可能由其委托的委托方法来处理。这些通知的名称应该能够反应其 响应的委托方法。比如,当应用程序􏰁交 NSApplicationDidBecomeActiveNotification 通知时,全局 NSApplication 对象的委托会注册从而能够接收 applicaitonDidBecomeActive: 消息。&lt;br&gt;通知由具有如下形式的全局 NSString 对象标识:&lt;br&gt;[相关联类的名称] + [Did 或 Will] + [UniquePartOfName] + Notification&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSApplicationDidBecomeActiveNotification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSWindowDidMiniaturizeNotification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSTextViewDidChangeSelectionNotification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSColorPanelColorDidChangeNotification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;开发中的一些小贴士&quot;&gt;&lt;a href=&quot;#开发中的一些小贴士&quot; class=&quot;headerlink&quot; title=&quot;开发中的一些小贴士&quot;&gt;&lt;/a&gt;开发中的一些小贴士&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;initialize&lt;/code&gt;类方法中,能够编写实现一些延迟执行且只被一次的代码,&lt;code&gt;initialize&lt;/code&gt;类方法是由运行时系统在该类响应任何其他消息之前调用的。典型的应用是在其中设置类的版本信息。运行时系统向每个类发送&lt;code&gt;initialize&lt;/code&gt;消息,即使该类没有实现&lt;code&gt;initialize&lt;/code&gt;,也会调用其基类的某个&lt;code&gt;initialize&lt;/code&gt;方法。因此一个类的&lt;code&gt;initialize&lt;/code&gt;方法可能会因为存在继承类的缘故被执行多次。因此有必要使用一定的技巧来防止只执行一次的代码被多次执行。如:&lt;code&gt;NSFoo&lt;/code&gt;类的&lt;code&gt;initialize&lt;/code&gt;方法实现可能如下:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;) initialize&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; == [&lt;span class=&quot;built_in&quot;&gt;NSFoo&lt;/span&gt; class])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//初始化代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;要注意不应当显式调用initialize方法。如果你需要激活initialize方法,使用[NSFoo self]形式的调用。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h3&gt;&lt;p&gt;习惯是平时一点点养成的，只要坚持就会有好的习惯。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;为什么要有编码规范这么一说呢？你设想一下如果张三写代码一个风格，李四一个风格，当张三去看李四的时候他会极度的不舒服，反过来李四去看张三的代码的时候也会感觉非常的糟糕。所以他们两个人遵循同一个规则的时候，再去看对方的代码的时候就不会不适应，因此指定一个大家都遵循的代码编程风格就至关重要了。对于iOS开发，苹果官方就制定了一套编码规范。作为iOS开发者遵循苹果制定的编码规范写代码，那么在看苹果的官方代码的时候就觉得很轻松了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码规范" scheme="zhangfei.tk/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Runtime实战之导航控制器那些事</title>
    <link href="zhangfei.tk/2015/12/05/Runtime%E5%AE%9E%E6%88%98%E4%B9%8B%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>zhangfei.tk/2015/12/05/Runtime实战之导航控制器那些事/</id>
    <published>2015-12-05T03:11:11.000Z</published>
    <updated>2016-03-23T04:59:30.000Z</updated>
    
    <content type="html">&lt;p&gt;在捣鼓导航效果的时候发现了很多有趣的东西，最后还用到了Runtime，在这里和大家分享一下我捣鼓导航效果的一些心得吧。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在使用天猫，网易新闻这些APP的时候，发现他们在push的时候。不是系统的效果。系统的效果是下面这种：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/cfaa8811jw1eyd9isdhaug208s0fqdi1.gif&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;然而天猫或者网易新闻的效果是下面这种：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/cfaa8811jw1eymkmq9htuj208t0d9aam.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;你注意到了吗？Apple自带的是返回上一页的手势必须贴近页面的左边的边缘，而在想天猫或者网易新闻这样的返回手势不用贴近边缘也是可以的。系统是没有提供方法给我们直接修改边缘手势的方法。系统的这个手势叫&lt;code&gt;interactivePopGestureRecognizer&lt;/code&gt;，在UINavigationController中对于他的定义是&lt;code&gt;readonly&lt;/code&gt;,因此我们只有想别的办法达到全屏(或半屏)手势的效果。&lt;/p&gt;
&lt;h4 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h4&gt;&lt;p&gt;这个方法比较笨，就是给每个页面添加一个滑动手势，监听向左滑的时候触发控制器&lt;code&gt;pop&lt;/code&gt;操作即可。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIPanGestureRecognizer&lt;/span&gt; *pan = [[&lt;span class=&quot;built_in&quot;&gt;UIPanGestureRecognizer&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; action:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(popHandle)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pan.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view addGestureRecognizer:pan];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.interactivePopGestureRecognizer.enabled = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后再代理方法做一些细节处理就可以达到全屏返回手势的效果了。当然如果APP都要用这个手势的话，可以把这个方法写到基类里面，这样就不用每个页面都得动手写一个了。&lt;/p&gt;
&lt;h4 id=&quot;方法二&quot;&gt;&lt;a href=&quot;#方法二&quot; class=&quot;headerlink&quot; title=&quot;方法二&quot;&gt;&lt;/a&gt;方法二&lt;/h4&gt;&lt;p&gt;直接替换系统的&lt;code&gt;UIGestureRecognizer&lt;/code&gt;，苹果虽然设置navigationcontroller的这个属性为readonly，但是我们可以用Runtime的特性将其替换为我们自己手势。通过kvc我们可以获取&lt;code&gt;UIGestureRecognizer&lt;/code&gt;的target,target的action是&lt;code&gt;handleNavigationTransition:&lt;/code&gt;只要我们将系统的手势拦截，替换成自己手势就ok了。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; target = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.interactivePopGestureRecognizer.delegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIPanGestureRecognizer&lt;/span&gt; *pan = [[&lt;span class=&quot;built_in&quot;&gt;UIPanGestureRecognizer&lt;/span&gt; alloc] initWithTarget:target action:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(handleNavigationTransition:)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pan.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view addGestureRecognizer:pan];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.interactivePopGestureRecognizer.enabled = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;拦截手势，做一定的处理&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)gestureRecognizerShouldBegin:(&lt;span class=&quot;built_in&quot;&gt;UIGestureRecognizer&lt;/span&gt; *)gestureRecognizer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.childViewControllers.count == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;仿天猫导航栏pop效果&quot;&gt;&lt;a href=&quot;#仿天猫导航栏pop效果&quot; class=&quot;headerlink&quot; title=&quot;仿天猫导航栏pop效果&quot;&gt;&lt;/a&gt;仿天猫导航栏pop效果&lt;/h4&gt;&lt;p&gt;细心的你，会发现系统自带返回的时候&lt;code&gt;navigationBar&lt;/code&gt;和天猫网易新闻的不一样。系统的效果&lt;code&gt;navigationBar&lt;/code&gt;不会随着页面一起走，而是在前后两个页面的bar有一个动画效果。由于iOS的&lt;code&gt;navigationBar&lt;/code&gt;是由&lt;code&gt;NavigationController&lt;/code&gt;管理的。所以在&lt;code&gt;viewControlle&lt;/code&gt;r中无法管理&lt;code&gt;navigationBar&lt;/code&gt;,所以要达到bar随页面一起走的效果要用系统原生方法还没发儿办到。在做项目时，发现B页面到A页面的时候，当A页面隐藏了navigationBar的时候，效果就类似于天猫的那个效果，如下图：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/cfaa8811jw1eyd9b5mn6gg208s0fqjsx.gif&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;这个效果只有类似于两个页面一个有bar，一个无bar的情况下才会有的效果。并且在pop的时候也需要注意把pop动画设置为YES才行。如果想要两个页面都有bar的时候也有这种效果，系统没有原生方法的。我能想到的就是将系统自带的bar隐藏，自己做一个bar，讲自己做的bar作为viewController的属性，这样就能达到类似天猫，网易新闻那样的效果了。带着这样的方法，我把自己的手机越狱用&lt;code&gt;Reveal&lt;/code&gt;查看了一下天猫，网易新闻的界面布局，从下面的图中，我们可以看到天猫就是采用了自己做的bar，自定义了导航控制器。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1ez0prxt0lfj211y0k479r.jpg&quot; alt=&quot;天猫界面结构图&quot;&gt;&lt;/center&gt;

&lt;p&gt;对于这个效果，个人很是喜欢，于是简单封装了一下&lt;code&gt;NavigationController&lt;/code&gt;，将全屏返回手势加进去了。如果你用得着的话，只需将你的导航控制器继承或者直接用ZFNavigationController初始化就可以了，对于storyboard利用Xcode的Runtime Attributes就可以使用了。效果图如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/cfaa8811jw1ez0fikjqltg208s0fodl2.gif&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;如果需要了解详细用法，请移步到&lt;a href=&quot;https://github.com/zhangfeidev/ZFNavigationController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;br&gt;如果你喜欢我的文章，不妨小额打赏，(&lt;em&gt;^__^&lt;/em&gt;) 嘻嘻……&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1ey7veld0soj205k05l74a.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在捣鼓导航效果的时候发现了很多有趣的东西，最后还用到了Runtime，在这里和大家分享一下我捣鼓导航效果的一些心得吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="iOS进阶" scheme="zhangfei.tk/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Runtime用法简要剖析</title>
    <link href="zhangfei.tk/2015/11/19/Runtime%E7%94%A8%E6%B3%95%E5%89%96%E6%9E%90/"/>
    <id>zhangfei.tk/2015/11/19/Runtime用法剖析/</id>
    <published>2015-11-18T16:00:00.000Z</published>
    <updated>2016-03-23T05:00:50.000Z</updated>
    
    <content type="html">&lt;p&gt;在对导航栏进行深度学习的时候，在网上发现&lt;a href=&quot;http://weibo.com/u/1364395395?from=feed&amp;amp;loc=at&amp;amp;nick=%E6%88%91%E5%B0%B1%E5%8F%ABSunny%E6%80%8E%E4%B9%88%E4%BA%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@我就叫Sunny怎么了&lt;/a&gt;&lt;br&gt;开源了一个导航栏返回手势的库&lt;a href=&quot;https://github.com/forkingdog/FDFullscreenPopGesture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FDFullscreenPopGesture&lt;/a&gt;,我看了看源代码，作者使用Runtime的一些知识实现的，今天我就借这个库的源代码进行Runtime的用法进行学习。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;如果看过我前面几篇关于Runtime的文章，应该知道Runtime的消息发送机制的原理是对象根据方法编号SEL去映射表查找对应的方法实现。因此在运行时阶段我们利用Runtime的一些方法可以帮助我们实现用正常方法很难办到的事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-给分类动态添加属性&quot;&gt;&lt;a href=&quot;#1-给分类动态添加属性&quot; class=&quot;headerlink&quot; title=&quot;1.给分类动态添加属性&quot;&gt;&lt;/a&gt;1.给分类动态添加属性&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;FDFullscreenPopGesture&lt;/code&gt;中给UIViewController的分类里有这么一个属性：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) _FDViewControllerWillAppearInjectBlock fd_willAppearInjectBlock;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是一个block的属性，block定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^_FDViewControllerWillAppearInjectBlock)(&lt;span class=&quot;built_in&quot;&gt;UIViewController&lt;/span&gt; *viewController, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; animated);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看到这里也许你会提问，OC中不是不能给分类添加属性么？正常情况下，OC是不允许给OC添加属性的。但是利用Runtime的特性，这是可以办到的。实现方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (_FDViewControllerWillAppearInjectBlock)fd_willAppearInjectBlock&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, _cmd);&lt;span class=&quot;comment&quot;&gt;// 根据关联的key，获取关联的值。这里的key等于_cmd,_cmd等于fd_willAppearInjectBlock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setFd_willAppearInjectBlock:(_FDViewControllerWillAppearInjectBlock)block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 第一个参数：给哪个对象添加关联&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 第二个参数：关联的key，通过这个key获取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 第三个参数：关联的value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 第四个参数:关联的策略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_setAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(fd_willAppearInjectBlock), block, OBJC_ASSO&lt;span class=&quot;built_in&quot;&gt;CIATION_COPY_NONATOMIC&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//关联对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;动态给分类添加属性的方法是：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_setAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; value, objc_AssociationPolicy policy)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;获取这个属性的方法是：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还有一个方法是移除属性：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_removeAssociatedObjects(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;是的，这样就动态的给&lt;code&gt;UIViewController&lt;/code&gt;的分类添加了&lt;code&gt;fd_willAppearInjectBlock&lt;/code&gt;这么一个属性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE：在使用Runtime的这些方法的时候不要忘了导入&lt;code&gt;objc/runtime.h&lt;/code&gt;这个头文件哦！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-动态添加方法&quot;&gt;&lt;a href=&quot;#2-动态添加方法&quot; class=&quot;headerlink&quot; title=&quot;2.动态添加方法&quot;&gt;&lt;/a&gt;2.动态添加方法&lt;/h3&gt;&lt;p&gt;要想动态添加方法我们必须了解方法是如何执行的，通常我们调用方法是通过&lt;code&gt;[object message]&lt;/code&gt;这种方法，除了这种方法还有一种是比较少用的，就是&lt;code&gt;[object performSelector:@selector(message)]&lt;/code&gt;这种方式。通过下面这张图我们可以了解一下他们对消息的处理的不同之处。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1ey7v8615vhj20sd0l8n41.jpg&quot; alt=&quot;iOS消息转发.png&quot;&gt;&lt;/center&gt;

&lt;p&gt;通过上图，我们可以得知，要想动态添加方法必须是通过&lt;code&gt;[object performSelector:@selector(message)]&lt;/code&gt;这种方式调用方法才能在运行时阶段通过Runtime的一些方法达到动态的添加方法。如果现在有一个&lt;code&gt;Person&lt;/code&gt;类，在其它地方通过&lt;code&gt;performSelector&lt;/code&gt;的方式调用&lt;code&gt;Person&lt;/code&gt;的&lt;code&gt;run&lt;/code&gt;方法。但是&lt;code&gt;Person&lt;/code&gt;类中并没有实现这个方法。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Person p = [Person alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这个时候即使Person类没有实现run方法编译器也不会报错&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[p performSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(run)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这时候只需要在&lt;code&gt;Person&lt;/code&gt;中实现&lt;code&gt;resolveInstanceMethod:&lt;/code&gt;方法就可以达到动态添加方法的目的。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//首先我们要在Person类里面实现我们要动态添加的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 要注意，默认方法都有两个隐式参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; run(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;,SEL sel)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@ %@&quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;NSStringFromSelector&lt;/span&gt;(sel));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 刚好可以用来判断未实现的方法是不是我们想要动态添加的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)resolveInstanceMethod:(SEL)sel&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//先判断一下传过来的是不是run方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sel == &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(run))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//如果是run方法就动态添加run方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        class_addMethod(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.class, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(run),(IMP)run, &lt;span class=&quot;string&quot;&gt;&quot;v@:&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第一个参数：给哪个类添加方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第二个参数：添加方法的方法编号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第三个参数：添加方法的函数实现（函数地址）,如果是OC方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//可以用+(IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第四个参数：方法的签名，(返回值+参数类型) v:void @:对象-&amp;gt;self :表示SEL-&amp;gt;_cmd&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样就达到了给一个类动态添加方法的效果了，如果想把方法转发给其他的类实现，需要处理消息转发的第二或第三个函数了。&lt;/p&gt;
&lt;h3 id=&quot;3-替换系统自带的方法&quot;&gt;&lt;a href=&quot;#3-替换系统自带的方法&quot; class=&quot;headerlink&quot; title=&quot;3.替换系统自带的方法&quot;&gt;&lt;/a&gt;3.替换系统自带的方法&lt;/h3&gt;&lt;p&gt;当一些时候，系统自带效果满足不了我们的时候，要么我们自定义，要么直接替换系统的方法。在公有的API是没有方法办到的。我们来看一段&lt;code&gt;FDFullscreenPopGesture&lt;/code&gt;的代码(注释是我加的)：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)load&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class class = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; class];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//获取系统方法的SEL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SEL originalSelector = &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(viewWillAppear:);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//获取替换方法的SEL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SEL swizzledSelector = &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(fd_viewWillAppear:);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//为了获取IMP指针，获得方法的Method&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Method originalMethod = class_getInstanceMethod(class, originalSelector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//为了安全起见，先判断是否已经存在要交换的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (success) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            method_exchangeImplementations(originalMethod, swizzledMethod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)fd_viewWillAppear:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)animated&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//不要认为这句代码有错，其实很好理解，在调用这句的时候方法已经交换了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Forward to primary implementation.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; fd_viewWillAppear:animated];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.fd_willAppearInjectBlock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.fd_willAppearInjectBlock(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, animated);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过上面的代码我们可以看出来，替换系统自带的方式实现需要用到的重要方法是&lt;code&gt;method_exchangeImplementations()&lt;/code&gt;方法，并且要注意替换方法里面对自己的调用。这个方法也就是人们常说的&lt;code&gt;Method Swizzling&lt;/code&gt;黑魔法，用的时候要注意，这是一把双刃剑！&lt;/p&gt;
&lt;h3 id=&quot;结尾&quot;&gt;&lt;a href=&quot;#结尾&quot; class=&quot;headerlink&quot; title=&quot;结尾&quot;&gt;&lt;/a&gt;结尾&lt;/h3&gt;&lt;p&gt;Runtime在项目中很少用，但是要理解它，理解了之后用起来也不危险。如果你喜欢我的文章，不妨扫一扫下面的二维码请我喝杯茶。祝大家在iOS开发的道路上玩得愉快！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1ey7veld0soj205k05l74a.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在对导航栏进行深度学习的时候，在网上发现&lt;a href=&quot;http://weibo.com/u/1364395395?from=feed&amp;amp;loc=at&amp;amp;nick=%E6%88%91%E5%B0%B1%E5%8F%ABSunny%E6%80%8E%E4%B9%88%E4%BA%86&quot;&gt;@我就叫Sunny怎么了&lt;/a&gt;&lt;br&gt;开源了一个导航栏返回手势的库&lt;a href=&quot;https://github.com/forkingdog/FDFullscreenPopGesture&quot;&gt;FDFullscreenPopGesture&lt;/a&gt;,我看了看源代码，作者使用Runtime的一些知识实现的，今天我就借这个库的源代码进行Runtime的用法进行学习。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Objective-C" scheme="zhangfei.tk/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>你要理解的Runtime知识点</title>
    <link href="zhangfei.tk/2015/11/15/%E4%BD%A0%E8%A6%81%E7%90%86%E8%A7%A3%E7%9A%84Runtime%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>zhangfei.tk/2015/11/15/你要理解的Runtime知识点/</id>
    <published>2015-11-14T16:00:00.000Z</published>
    <updated>2016-03-23T05:02:39.000Z</updated>
    
    <content type="html">&lt;p&gt;在学习Runtime的过程中，有不少的知识点是平时难以接触到的。所以刚开始接触Runtime的时候会碰到好些不熟悉的小知识点。下面就随我扒一扒Runtime中那些需要知道的小知识点吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;SEL&quot;&gt;&lt;a href=&quot;#SEL&quot; class=&quot;headerlink&quot; title=&quot;SEL&quot;&gt;&lt;/a&gt;SEL&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SEL&lt;/code&gt;是一种类型，该类型表示对方法的一种封装，平时我们说的选择器selector就是它啦！Objective-C在编译时候呢，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。也就是说每一个SEL对应一个方法，根据一个SEL就能找到一个方法，然后对它进行调用等操作。其实我们也可以理解为SEL是一个方法的指针（实际上不是）。来看看它的真面目吧,在&lt;code&gt;objc.h&lt;/code&gt;的49行处可以发现：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// An opaque type that represents a method selector.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_selector *SEL;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样看来SEL的本质是一个&lt;code&gt;objc_selector&lt;/code&gt;类型的结构体指针。那该如何生成一个SEL类型的数据呢?编译器提供的有选择器@selector，NSSelectorFromString()方法，sel_registerName函数。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SEL methodSel1 = &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(method);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SEL methodSel2 = &lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;(method);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE：只要方法名一样，那么这个方法的SEL就一样，不管同名的方法是有没有关系（继承）,即使在不同的类方法名一样那么这个方法的SEL也是一样的。但是同一个类中不能存在同名方法（即使参数类型一样也不行，当然参数个数不一样可以），在不同的类里面是可以有同名方法的，不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。&lt;/p&gt;
&lt;h3 id=&quot;IMP&quot;&gt;&lt;a href=&quot;#IMP&quot; class=&quot;headerlink&quot; title=&quot;IMP&quot;&gt;&lt;/a&gt;IMP&lt;/h3&gt;&lt;p&gt;上面讲了，根据SEL能寻找到函数，其实IMP才是真正指向函数的指针，它指向了函数实现的首地址。其实SEL就是为了查找方法的IMP的。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE:通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Method&quot;&gt;&lt;a href=&quot;#Method&quot; class=&quot;headerlink&quot; title=&quot;Method&quot;&gt;&lt;/a&gt;Method&lt;/h3&gt;&lt;p&gt;Method是一个结构体，用于表示类中定义的方法。实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;方法操作相关函数：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 调用指定方法的实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; method_invoke ( &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; receiver, Method m, ... );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 调用返回一个数据结构的方法的实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; method_invoke_stret ( &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; receiver, Method m, ... );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取方法名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SEL method_getName ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回方法的实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMP method_getImplementation ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取描述方法参数和返回值类型的字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * method_getTypeEncoding ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取方法的返回值类型的字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * method_copyReturnType ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取方法的指定位置参数的类型字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * method_copyArgumentType ( Method m, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过引用返回方法的返回值类型字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; method_getReturnType ( Method m, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *dst, size_t dst_len );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回方法的参数的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; method_getNumberOfArguments ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过引用返回方法指定位置参数的类型字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; method_getArgumentType ( Method m, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *dst, size_t dst_len );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回指定方法的方法描述结构体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_description * method_getDescription ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 设置方法的实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMP method_setImplementation ( Method m, IMP imp );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 交换两个方法的实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; method_exchangeImplementations ( Method m1, Method m2 );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这些函数在通过Runtime实现一些东西的时候或者在看别人的代码的时候或许能用到，只需要知道有这么一些函数就可以了。&lt;/p&gt;
&lt;h3 id=&quot;Class&quot;&gt;&lt;a href=&quot;#Class&quot; class=&quot;headerlink&quot; title=&quot;Class&quot;&gt;&lt;/a&gt;Class&lt;/h3&gt;&lt;p&gt;Class在我的一篇文章中有详细的讲解，请移步&lt;a href=&quot;http://zhangfei.tk/2015/11/14/OC%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%EF%BC%9F/#more&quot;&gt;OC中的类是怎么来的？&lt;/a&gt;,这里不在赘诉了。&lt;/p&gt;
&lt;h3 id=&quot;cmd&quot;&gt;&lt;a href=&quot;#cmd&quot; class=&quot;headerlink&quot; title=&quot;_cmd&quot;&gt;&lt;/a&gt;_cmd&lt;/h3&gt;&lt;p&gt;通过_cmd这个关键字能获取当前方法的&lt;code&gt;SEL&lt;/code&gt;。看个栗子吧：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)testCmd &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL currentMethodSel = _cmd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;currentSel is :%s&quot;&lt;/span&gt;,(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *)currentMethodSel);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的打印结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;currentSel is :testCmd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;objc-msgSend&quot;&gt;&lt;a href=&quot;#objc-msgSend&quot; class=&quot;headerlink&quot; title=&quot;objc_msgSend&quot;&gt;&lt;/a&gt;objc_msgSend&lt;/h3&gt;&lt;p&gt;在OC中，对方法的调用被称之为发送消息。其实我们对方法的调用最后都会被编译为下面的这种形式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于函数：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[target method1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[target method2:var];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;没有参数：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(target,&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(method1));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;有参数：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(target,&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(method2:),var);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法的调用过程在我的上一篇文章&lt;a href=&quot;http://zhangfei.tk/2015/11/14/OC%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%EF%BC%9F/#more&quot;&gt;OC中的类是怎么来的？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;结尾&quot;&gt;&lt;a href=&quot;#结尾&quot; class=&quot;headerlink&quot; title=&quot;结尾&quot;&gt;&lt;/a&gt;结尾&lt;/h3&gt;&lt;p&gt;有人说Runtime是OC的本质和精华，虽然我们在项目中不经常用，但是理解还是有很大的用处的。喜欢我的文章就给我鼓励吧！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1ey7veld0soj205k05l74a.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在学习Runtime的过程中，有不少的知识点是平时难以接触到的。所以刚开始接触Runtime的时候会碰到好些不熟悉的小知识点。下面就随我扒一扒Runtime中那些需要知道的小知识点吧！&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Objective-C" scheme="zhangfei.tk/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>OC中的类是怎么来的？</title>
    <link href="zhangfei.tk/2015/11/14/OC%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%EF%BC%9F/"/>
    <id>zhangfei.tk/2015/11/14/OC中的类是怎么来的？/</id>
    <published>2015-11-13T16:00:00.000Z</published>
    <updated>2016-03-23T04:59:06.000Z</updated>
    
    <content type="html">&lt;p&gt;我们都知道OC是在C语言的基础上增加了面向对象的编程特性。我们知道C语言并没有面向对象中的类的概念。细心的小伙伴会发现，C语言的结构体和类长得有点像。难道OC中的类和C语言的结构体有渊源？是的，你没有猜错，OC是一门动态语言，有一套运行时机制，会把OC中的类动态构造为C语言的结构体，不信？且往下看。Objective-C类是由Class类型来表示的。在&lt;code&gt;objc.h&lt;/code&gt;中可以找到OC中类的定义。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// An opaque type that represents an Objective-C class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class *Class;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从这里可以看出来OC中的类其实是C语言中的一个结构体指针，它指向了&lt;code&gt;objc_class&lt;/code&gt;这个结构体。进一步跟踪，在&lt;code&gt;runtime.h&lt;/code&gt;可以看到&lt;code&gt;objc_class&lt;/code&gt;的定义，如下(根据我自己的理解添加了注释)：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_&lt;span class=&quot;built_in&quot;&gt;AVAILABILITY&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//指向自己的真实类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#if !__OBJC2__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class super_class                        OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//指向父类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//类名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; version                             OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//类的版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; info                                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//类的信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; instance_size                       OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//类实例大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar_list *ivars             OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//类的成员变量链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list **methodLists    OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//类的方法定义链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_cache *cache                 OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//方法缓存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols     OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//类的协议链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;详细看一下结构体的成员变量是干啥的吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isa&lt;/code&gt;：每一个对象都有一个叫isa的指针类型的成员变量，它指向该对象的实际类型(比如有一个Person类，他有一个p1的实例对象，那么这个p1的成员变量isa指向的就是Person类)，需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;super_class&lt;/code&gt;:和isa一样，也是一个指针类型的，它指向了自己的父类。那NSObject类的super_class指向什么呢？答案是指向NULL。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;:这个是记录类的名字用的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;version&lt;/code&gt;:记录类的版本用的。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info&lt;/code&gt;:类的信息，主要作用是在运行期间做一些标识。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance_size&lt;/code&gt;:记录类实例对象的占用空间的大小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ivars&lt;/code&gt;:类的成员变量不可能总是一个，所以类的成员变量就用了一个链表来记录。我们可以看到这个&lt;code&gt;objc_ivar_list&lt;/code&gt;是一个结构体，在&lt;code&gt;runtime.h&lt;/code&gt;的1655行的位置就能找到&lt;code&gt;objc_ivar_list&lt;/code&gt;这个结构体的声明：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar_list &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ivar_count                                           OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#ifdef __LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; space                                                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* variable length structure */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar ivar_list[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]                            OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;objc_ivar_list&lt;/code&gt;这个结构体里面还有一个&lt;code&gt;objc_ivar&lt;/code&gt;的结构体，它的声明就&lt;code&gt;objc_ivar_list&lt;/code&gt;这个结构体的上面，声明是这个样子的：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *ivar_name                                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *ivar_type                                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ivar_offset                                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#ifdef __LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; space                                                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;objc_method_list&lt;/code&gt;：类的方法也和成员变量一个道理，因此也是用一个链表来记录的。也许你会疑惑为什么&lt;code&gt;objc_method_list&lt;/code&gt;是指针的指针，先看一看它的结构体实现吧，位置是&lt;code&gt;runtime.h&lt;/code&gt;的1671行：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list *obsolete                        OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; method_count                                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#ifdef __LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; space                                                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* variable length structure */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method method_list[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]                        OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个结构体的声明里面可以看到里面有一个叫&lt;code&gt;objc_method_list&lt;/code&gt;的结构体指针，这样我们不就不难理解它是一个指针的指针了。这里面的结构体&lt;code&gt;objc_method&lt;/code&gt;的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL method_name                                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *method_types                                       OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    IMP method_imp                                           OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cache&lt;/code&gt;:cache是用来记录方法调用的，每当调用方法的时候就先到这里查一下这个方法有没有被调用过。如果被调用过就直接想这个方法发送消息，如果没有才去&lt;code&gt;methodLists&lt;/code&gt;里面去查找。同样是在&lt;code&gt;runtime.h&lt;/code&gt;中我们找到结构体&lt;code&gt;objc_cache&lt;/code&gt;的定义：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_cache &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mask &lt;span class=&quot;comment&quot;&gt;/* total = mask + 1 */&lt;/span&gt;                 OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; occupied                                    OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Method buckets[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]                                        OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也许你会发现一个&lt;code&gt;Method&lt;/code&gt;的类，其实他的本质就是上面的&lt;code&gt;objc_method&lt;/code&gt;这个结构体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;protocols&lt;/code&gt;：和方法链表，成员变量一样。用来记录协议的链表。它的定义如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Protocol *list[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这下明白了吧，OC的类和C语言还有这么一层关系，当然这都归功于OC的Runtime机制。&lt;/p&gt;
&lt;p&gt;在面向对象编程中不仅有类的概念，还有实例对象的概念，既然类与C语言的结构体有着千丝万缕的关系，那么，类对象想必也和C语言撇不开关系吧。是的，有什么关系呢？往下看！&lt;/p&gt;
&lt;p&gt;上面说了类是怎么构造的，那你不禁会问类对象是怎么构造的呢？其实就在&lt;code&gt;objc.h&lt;/code&gt;文件里声明Class结构体下面就可以发现这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// Represents an instance of a class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_&lt;span class=&quot;built_in&quot;&gt;AVAILABILITY&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从注释中不难看出，结构体&lt;code&gt;objc_object&lt;/code&gt;表示的是类对象，可以看到，这个结构体只有一个成员变量，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。也就是是说当我们创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。&lt;/p&gt;
&lt;h4 id=&quot;结尾&quot;&gt;&lt;a href=&quot;#结尾&quot; class=&quot;headerlink&quot; title=&quot;结尾&quot;&gt;&lt;/a&gt;结尾&lt;/h4&gt;&lt;p&gt;上面讲的都要归功于牛逼的Runtime，那么Runtime有什么🐂👃的呢？有兴趣就看我的下一片文章。最后大家不要忘了，如果我的文章对你有帮助，你愿意请我喝杯茶的话，请用支付宝扫一扫下面的二维码随意打赏。祝大家玩得愉快！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1ey7veld0soj205k05l74a.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道OC是在C语言的基础上增加了面向对象的编程特性。我们知道C语言并没有面向对象中的类的概念。细心的小伙伴会发现，C语言的结构体和类长得有点像。难道OC中的类和C语言的结构体有渊源？是的，你没有猜错，OC是一门动态语言，有一套运行时机制，会把OC中的类动态构造为C语言的结构体，不信？且往下看。Objective-C类是由Class类型来表示的。在&lt;code&gt;objc.h&lt;/code&gt;中可以找到OC中类的定义。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Objective-C" scheme="zhangfei.tk/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>使用Reveal调试你的iOS程序</title>
    <link href="zhangfei.tk/2015/11/08/%E4%BD%BF%E7%94%A8Reveal%E8%B0%83%E8%AF%95%E4%BD%A0%E7%9A%84iOS%E7%A8%8B%E5%BA%8F/"/>
    <id>zhangfei.tk/2015/11/08/使用Reveal调试你的iOS程序/</id>
    <published>2015-11-08T03:11:11.000Z</published>
    <updated>2016-03-23T05:02:57.000Z</updated>
    
    <content type="html">&lt;p&gt;Reveal是一个很强大的UI分析工具，能够非常直观查看app的UI布局。它能够在运行时调试和修改iOS应用程序。Reveal能连接到应用程序，并允许开发者编辑各种用户界面参数，这反过来会立即反应在程序的UI上。就像用FireBug调试HTML页面一样，在不需要重写代码、重新构建和重新部署应用程序的情况下就能够调试和修改iOS用户界面。用起来超级酸爽！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;Reveal下载地址：&lt;a href=&quot;http://revealapp.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reveal官网&lt;/a&gt;。Reveal是一个收费软件，但是可以免费试用30天，如果你是短期用用，免费试用就够了。如果要长期使用，你可以Google破解教程，不过我还是推荐购买，毕竟程序员也不容易。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;在项目中使用Reveal调试&quot;&gt;&lt;a href=&quot;#在项目中使用Reveal调试&quot; class=&quot;headerlink&quot; title=&quot;在项目中使用Reveal调试&quot;&gt;&lt;/a&gt;在项目中使用Reveal调试&lt;/h4&gt;&lt;p&gt;首先需要把Reveal的framework导入到项目中，那这个framework在哪里找呢？打开你下载的Mac程序Reveal，如下图便可找到Reveal的framework了。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1ey7vo5xbu5j20m607p778.jpg&quot; alt=&quot;RevealFramework.png&quot;&gt;&lt;/center&gt;

&lt;p&gt;将framework导入到工程之后，你会发现当你编译的时候你会发现有错误，这时候该怎么办呢？只需要设置设置两个地方就会让烦心的错误消失。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择&lt;code&gt;Build Phases&lt;/code&gt;标签，如果在&lt;code&gt;Link Binary With Libraries&lt;/code&gt;配置项中已有&lt;code&gt;Reveal.framework&lt;/code&gt;，请将其移除。&lt;/li&gt;
&lt;li&gt;选择&lt;code&gt;Build Settings&lt;/code&gt;标签，在&lt;code&gt;Other Linker Flags&lt;/code&gt;的&lt;code&gt;Debug&lt;/code&gt;配置项中加入如下配置&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-ObjC -lz -framework Reveal&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这时候你在编译就没问题了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE：Reveal只是用来做调试之用，要注意不要把它打包到发布包中去了。关于这个问题你可以移步&lt;a href=&quot;http://support.revealapp.com/kb/getting-started/revealxcodereveal&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;看看该怎么做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在一切设置都结束了，运行你的程序，打开Reveal，点击左上角的那个&lt;code&gt;No Connection&lt;/code&gt;选择你运行程序的那个模拟器开始酸爽的Reveal之旅吧。下面给大家看看图吧！是不是很炫酷的赶脚。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/cfaa8811jw1ey7vnw92qcj21g10tawlp.jpg&quot; alt=&quot;TaoBao.png&quot;&gt;&lt;/center&gt;

&lt;h4 id=&quot;在真机上使用Reveal调试&quot;&gt;&lt;a href=&quot;#在真机上使用Reveal调试&quot; class=&quot;headerlink&quot; title=&quot;在真机上使用Reveal调试&quot;&gt;&lt;/a&gt;在真机上使用Reveal调试&lt;/h4&gt;&lt;p&gt;看完上面在模拟器上用Reveal调试自己的项目，可能聪明的你已经想到要看看别人的APP是怎么布局的吧！细心的人会发现上面博主给的图就是分析的别人的APP。这该怎么做呢？这个就要用到真机了，而且这个还是属于逆向工程的范围哦！这个真机要是越狱了的。只有越狱了的系统才能把Reveal的framework嵌入到别人的APP中嘛。那该如何实现将Reveal的framework加载到别人的APP中呢？在&lt;code&gt;iOS应用逆向工程&lt;/code&gt;这本书里的&lt;a href=&quot;http://zhuanlan.zhihu.com/iOSRe/19646016&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一篇文章&lt;/a&gt;讲到需要将libReveal.dylib上传到设备的/Library/MobileSubstrate/DynamicLibraries。然后编辑一个名为libReveal.plist文件，也放在该目录下面。这样当电脑和越狱设备在同一个Wi-Fi环境下就可以查看别人的APP布局了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE：博主曾经为了真机测试，跟着这个步骤走的时候，没有编辑那个plist文件，把自己的机器搞成白苹果了。所以一定要跟着那篇文章中的提示编辑一个plist文件，不然机器就真的很可能白苹果了。对了，如果你不会SSH上传文件的话，你可以用助手软件小白式的上传哦！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果上述方法不成功，还有一个非常简单的方法。就是在你的手机上安装插件&lt;a href=&quot;https://github.com/heardrwt/RevealLoader&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RevealLoader&lt;/a&gt;。不会安装插件？看&lt;a href=&quot;http://www.jianshu.com/p/f47db3b4d3f8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。这个插件使用起来才叫真正的酸爽啊！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE：如果你面的这些你都认认真真的做了，但是你的Reveal界面不能选择真机的话，你可以考虑一下是不是你的&lt;code&gt;在同一个Wi-Fi环境下&lt;/code&gt;出了问题，验证方法就是用你的手机建立一个热点让电脑连上，这样做绝逼是在同一个Wi-Fi环境下。如果还是不行的话，你就得检查一下你的Reveal版本是不是和手机插件都是最新版哦。话说不是最新版也没关系，只要你把你电脑上的Reveal库传到手机上的/Library/RHRevealLoader目录下覆盖原来的那个就OK咯！要是你没有这个目录那你就更杯具了，那是由于你的插件没有安装成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;结尾&quot;&gt;&lt;a href=&quot;#结尾&quot; class=&quot;headerlink&quot; title=&quot;结尾&quot;&gt;&lt;/a&gt;结尾&lt;/h4&gt;&lt;p&gt;想要玩好Reveal？或许你可以去下面这些地方看看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://support.revealapp.com/kb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reveal支持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://revealapp.com/blog/reveal-common-tips-cn.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reveal小技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你觉得我的文章对你有帮助，可以随意打赏，再少也是一种鼓励。最后住大家玩得开心！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1ey7veld0soj205k05l74a.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Reveal是一个很强大的UI分析工具，能够非常直观查看app的UI布局。它能够在运行时调试和修改iOS应用程序。Reveal能连接到应用程序，并允许开发者编辑各种用户界面参数，这反过来会立即反应在程序的UI上。就像用FireBug调试HTML页面一样，在不需要重写代码、重新构建和重新部署应用程序的情况下就能够调试和修改iOS用户界面。用起来超级酸爽！&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="工具" scheme="zhangfei.tk/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS中推出键盘的几种方式</title>
    <link href="zhangfei.tk/2015/10/28/iOS%E4%B8%AD%E6%8E%A8%E5%87%BA%E9%94%AE%E7%9B%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>zhangfei.tk/2015/10/28/iOS中推出键盘的几种方式/</id>
    <published>2015-10-28T03:11:11.000Z</published>
    <updated>2016-03-23T04:54:22.000Z</updated>
    
    <content type="html">&lt;p&gt;在使用&lt;code&gt;UITextField&lt;/code&gt;的时候，我们会和键盘打交道，有时候要求弹出来的键盘类型是数字键盘，有时候要求我们弹出来的是一般的键盘。当我们输入完成的时候，就涉及到在上什么时候收回键盘的事情了。收回键盘分下面的情况来讨论。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;大体来说，收起键盘的方法有：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;让textFiled放弃成为第一响应者(&lt;code&gt;resignFirstResponder&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;让view或者子view强制结束编辑状态(&lt;code&gt;endEditing&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-输入完以后用户点击return后收起键盘。&quot;&gt;&lt;a href=&quot;#1-输入完以后用户点击return后收起键盘。&quot; class=&quot;headerlink&quot; title=&quot;1.输入完以后用户点击return后收起键盘。&quot;&gt;&lt;/a&gt;1.输入完以后用户点击&lt;code&gt;return&lt;/code&gt;后收起键盘。&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;可以点击&lt;code&gt;return&lt;/code&gt;收起键盘并不意味着弹出来的键盘一定都有&lt;code&gt;return&lt;/code&gt;这个按键，比如数字键盘类型就没有，&lt;code&gt;UIKeyboardTypeWebSearch&lt;/code&gt;类型的键盘&lt;code&gt;return&lt;/code&gt;键就变成了&lt;code&gt;Go&lt;/code&gt;键，需要注意的是这时候的&lt;code&gt;Go&lt;/code&gt;键相当于&lt;code&gt;return&lt;/code&gt;键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要想实现点击&lt;code&gt;return&lt;/code&gt;让键盘收起，首先需要设置textField代理，当然还有遵循&lt;code&gt;UITextFieldDelegate&lt;/code&gt;协议:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_textField.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后实现协议方法&lt;code&gt;- (BOOL)textFieldShouldReturn:(UITextField *)textField;&lt;/code&gt;,当然你也可以在这个方法里 main实现一些需求逻辑，比如判断输入的内容符不符合要求等。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)textFieldShouldReturn:(&lt;span class=&quot;built_in&quot;&gt;UITextField&lt;/span&gt; *)textField&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [textField resignFirstResponder];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-点击背景后收起键盘&quot;&gt;&lt;a href=&quot;#2-点击背景后收起键盘&quot; class=&quot;headerlink&quot; title=&quot;2.点击背景后收起键盘&quot;&gt;&lt;/a&gt;2.点击背景后收起键盘&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;点击背景收起键盘可以实现view的&lt;code&gt;- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event&lt;/code&gt;方法，然后执行view的&lt;code&gt;- (BOOL)endEditing:(BOOL)force;&lt;/code&gt;方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)touchesBegan:(&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;UITouch&lt;/span&gt; *&amp;gt; *)touches withEvent:(&lt;span class=&quot;built_in&quot;&gt;UIEvent&lt;/span&gt; *)event&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view endEditing:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//实现该方法是需要注意view需要是继承UIControl而来的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还有一些比较笨的方法也可以实现达到点击背景后收起键盘的效果，比如：在背景view上面加手势，添加UIButton或者view，然后在对应的点击事件的监听方法中实现&lt;code&gt;resignFirstResponder&lt;/code&gt;或者&lt;code&gt;endEditing&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITapGestureRecognizer&lt;/span&gt; *tapGestureRecognizer = [[&lt;span class=&quot;built_in&quot;&gt;UITapGestureRecognizer&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; action:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(keyboardHide:)];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置成NO表示当前控件响应后会传播到其他控件上，默认为YES。  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tapGestureRecognizer.cancelsTouchesInView = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将触摸事件添加到view上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view addGestureRecognizer:tapGestureRecognizer];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)keyboardHide:(&lt;span class=&quot;built_in&quot;&gt;UITapGestureRecognizer&lt;/span&gt;*)tap&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [textFiled resignFirstResponder];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;3-不用view实现endEditing的方法&quot;&gt;&lt;a href=&quot;#3-不用view实现endEditing的方法&quot; class=&quot;headerlink&quot; title=&quot;3.不用view实现endEditing的方法&quot;&gt;&lt;/a&gt;3.不用view实现&lt;code&gt;endEditing&lt;/code&gt;的方法&lt;/h4&gt;&lt;p&gt;如果说在比较难获取viewController的view时，可以使用下面的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[[&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; sharedApplication] keyWindow] endEditing:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; sharedApplication] sendAction:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(resignFirstResponder) to:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; from:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; forEvent:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;结尾&quot;&gt;&lt;a href=&quot;#结尾&quot; class=&quot;headerlink&quot; title=&quot;结尾&quot;&gt;&lt;/a&gt;结尾&lt;/h3&gt;&lt;p&gt;在项目中还得根据情况选择使用哪一种方法，我想掌握上面的这些方法差不多就够了，祝大家玩得愉快！如果你觉得我的文章对你有帮助，不妨任性打赏😄！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1ey7veld0soj205k05l74a.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在使用&lt;code&gt;UITextField&lt;/code&gt;的时候，我们会和键盘打交道，有时候要求弹出来的键盘类型是数字键盘，有时候要求我们弹出来的是一般的键盘。当我们输入完成的时候，就涉及到在上什么时候收回键盘的事情了。收回键盘分下面的情况来讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="键盘" scheme="zhangfei.tk/tags/%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>关于扫一扫，是时候放弃第三方了!</title>
    <link href="zhangfei.tk/2015/10/23/%E5%85%B3%E4%BA%8E%E6%89%AB%E4%B8%80%E6%89%AB%EF%BC%8C%E6%98%AF%E6%97%B6%E5%80%99%E6%94%BE%E5%BC%83%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E4%BA%86/"/>
    <id>zhangfei.tk/2015/10/23/关于扫一扫，是时候放弃第三方库了/</id>
    <published>2015-10-23T03:11:11.000Z</published>
    <updated>2016-03-23T05:04:19.000Z</updated>
    
    <content type="html">&lt;p&gt;扫一扫这个功能我们并不陌生，微信QQ加好友扫一扫，路边搞推广的扫一扫，吃饭付钱扫一扫。看来这个扫一扫应用的地方还真不少啊！打开手机看了看安装的APP,社交类APP有扫一扫，支付类的APP有扫一扫，连浏览器都有扫一扫。看来这个扫一扫不可小视！说不定哪天在你的项目中你的boss就要你给他加个扫一扫的功能呢！对于iOS开发要想做扫一扫这个功能，并不是很难，我们需要做的就是处理二维码(QRCode)而已。在iOS7之前需要借助第三方库ZBar和ZXing。在iOS7以后用自带API就能轻松搞定。不用在项目中导入臃肿的第三方库和担心编译出问题了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;二维码是个什么鬼？&quot;&gt;&lt;a href=&quot;#二维码是个什么鬼？&quot; class=&quot;headerlink&quot; title=&quot;二维码是个什么鬼？&quot;&gt;&lt;/a&gt;二维码是个什么鬼？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;二维条码是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。—-维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细的生成细节和原理可以看看&lt;a href=&quot;http://coolshell.cn/articles/10590.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二维码的生成细节和原理&lt;/a&gt;这篇文章。&lt;/p&gt;
&lt;h3 id=&quot;扫描二维码&quot;&gt;&lt;a href=&quot;#扫描二维码&quot; class=&quot;headerlink&quot; title=&quot;扫描二维码&quot;&gt;&lt;/a&gt;扫描二维码&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;首先我们来想一想具体的步骤，大概流程应该是：1.打开设备的摄像头–&amp;gt;2.进行二维码图像捕获–&amp;gt;3.获取捕获的图像进行解析–&amp;gt;4.取得解析结果进行后续处理。这些流程需要用到&lt;code&gt;AVFoundation&lt;/code&gt;这个库，注意导入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//获取一个AVCaptureDevice对象，可以理解为打开摄像头这样的动作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; *device = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; defaultDeviceWithMediaType:&lt;span class=&quot;built_in&quot;&gt;AVMediaTypeVideo&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//获取一个AVCaptureDeviceInput对象，将上面的&#39;摄像头&#39;作为输入设备&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;AVCaptureDeviceInput&lt;/span&gt; *input = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDeviceInput&lt;/span&gt; deviceInputWithDevice:_device error:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//拍完照片以后，需要一个AVCaptureMetadataOutput对象将获取的&#39;图像&#39;输出，以便进行对其解析&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;AVCaptureMetadataOutput&lt;/span&gt; *output = [[&lt;span class=&quot;built_in&quot;&gt;AVCaptureMetadataOutput&lt;/span&gt; alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//获取输出需要设置代理，在代理方法中获取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[output setMetadataObjectsDelegate:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; queue:dispatch_get_main_queue()];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置输出类型，如AVMetadataObjectTypeQRCode是二维码类型，下面还增加了条形码。如果扫描的是条形码也能识别&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;output.metadataObjectTypes = @[&lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeEAN13Code&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    &lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeEAN8Code&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    &lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeCode128Code&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    &lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeQRCode&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面完成了捕获的设置，但是并未正在开始’扫描’，要完成一次扫描的过程，需要用到&lt;code&gt;AVCaptureSession&lt;/code&gt;这个类，这个session类把一次扫描看做一次会话，会话开始后才是正在的’扫描’开始,具体代码如下。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;AVCaptureSession&lt;/span&gt; *session = [[&lt;span class=&quot;built_in&quot;&gt;AVCaptureSession&lt;/span&gt; alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[session setSessionPreset:&lt;span class=&quot;built_in&quot;&gt;AVCaptureSessionPresetHigh&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//扫描的质量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([session canAddInput:input])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [session addInput:input];&lt;span class=&quot;comment&quot;&gt;//将输入添加到会话中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([session canAddOutput:output])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [session addOutput:output];&lt;span class=&quot;comment&quot;&gt;//将输出添加到会话中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来我们要做的不是立即开始会话(开始扫描)，如果你现在调用会话的&lt;code&gt;startRunning&lt;/code&gt;方法的话，你会发现屏幕是一片黑，这时由于我们还没有设置相机的取景器的大小。设置取景器需要用到&lt;code&gt;AVCaptureVideoPreviewLayer&lt;/code&gt;这个类。具体代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;AVCaptureVideoPreviewLayer&lt;/span&gt; *preview =[&lt;span class=&quot;built_in&quot;&gt;AVCaptureVideoPreviewLayer&lt;/span&gt; layerWithSession:session];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;preview.videoGravity = &lt;span class=&quot;built_in&quot;&gt;AVLayerVideoGravityResize&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[preview setFrame:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.bounds];&lt;span class=&quot;comment&quot;&gt;//设置取景器的frame&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.layer insertSublayer:preview atIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来我们就可以调用session的&lt;code&gt;startRunning&lt;/code&gt;方法了，这时我们的扫描就真正开始了。想要获得扫描的结果，需要实现session的代理方法&lt;code&gt;- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection&lt;/code&gt;,代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)captureOutput:(&lt;span class=&quot;built_in&quot;&gt;AVCaptureOutput&lt;/span&gt; *)captureOutput didOutputMetadataObjects:(&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)metadataObjects fromConnection:(&lt;span class=&quot;built_in&quot;&gt;AVCaptureConnection&lt;/span&gt; *)connection&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.session stopRunning];&lt;span class=&quot;comment&quot;&gt;//停止会话&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.preview removeFromSuperlayer];&lt;span class=&quot;comment&quot;&gt;//移除取景器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (metadataObjects.count &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;AVMetadataMachineReadableCodeObject&lt;/span&gt; *obj = metadataObjects[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *result = obj.stringValue;&lt;span class=&quot;comment&quot;&gt;//这就是扫描的结果啦&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//对结果进行处理...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果要做到为用户考虑的话，还得加入照明的功能或者设置兴趣区域。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设设置兴趣区域&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用过微信中的扫一扫的话，你应该发现在扫描界面中间有一个矩形限定框，这个框就是兴趣区域了。这个兴趣区域是&lt;code&gt;AVCaptureMetadataOutput&lt;/code&gt;的&lt;code&gt;rectOfInterest&lt;/code&gt;属性。&lt;code&gt;rectOfInterest&lt;/code&gt;的值的范围都是0-1,是按比例取值而不是实际尺寸,所以设置的时候要注意的一点。还要注意&lt;code&gt;rectOfInterest&lt;/code&gt;都是按照横屏来计算的，所以当竖屏的情况下x轴和y轴要交换一下。代码如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGSize&lt;/span&gt; size = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.bounds.size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGSize&lt;/span&gt; transparentAreaSize = &lt;span class=&quot;built_in&quot;&gt;CGSizeMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt; cropRect = &lt;span class=&quot;built_in&quot;&gt;CGRectMake&lt;/span&gt;((size.width - transparentAreaSize.width)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, (size.height - transparentAreaSize.height)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, transparentAreaSize.width, transparentAreaSize.height);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;output.rectOfInterest = &lt;span class=&quot;built_in&quot;&gt;CGRectMake&lt;/span&gt;(cropRect.origin.y/size.width,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                              cropRect.origin.x/size.height,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                              cropRect.size.height/size.height,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                              cropRect.size.width/size.width);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;加入照明功能&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;加入照明功能能让用户在光照条件不好的情况下顺利的进行进行扫描操作,代码如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; *device = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; defaultDeviceWithMediaType:&lt;span class=&quot;built_in&quot;&gt;AVMediaTypeVideo&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *error;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (device.hasTorch) &amp;#123;  &lt;span class=&quot;comment&quot;&gt;// 判断设备是否有闪光灯&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; b = [device lockForConfiguration:&amp;amp;error];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;lock torch configuration error:%@&quot;&lt;/span&gt;, error.localizedDescription);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    device.torchMode = (device.torchMode == &lt;span class=&quot;built_in&quot;&gt;AVCaptureTorchModeOff&lt;/span&gt; ? &lt;span class=&quot;built_in&quot;&gt;AVCaptureTorchModeOn&lt;/span&gt; : &lt;span class=&quot;built_in&quot;&gt;AVCaptureTorchModeOff&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [device unlockForConfiguration];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;从图片中读取二维码&quot;&gt;&lt;a href=&quot;#从图片中读取二维码&quot; class=&quot;headerlink&quot; title=&quot;从图片中读取二维码&quot;&gt;&lt;/a&gt;从图片中读取二维码&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从图片中直接读取二维码的功能在iOS7上面苹果没有实现，不过在iOS上已经填补了这一功能。主要用到的是读取主要用到CoreImage。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;废话不多说，直接上代码。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)scQRReaderForImage:(&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *)qrimage&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIContext&lt;/span&gt; *context = [&lt;span class=&quot;built_in&quot;&gt;CIContext&lt;/span&gt; contextWithOptions:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIDetector&lt;/span&gt; *detector = [&lt;span class=&quot;built_in&quot;&gt;CIDetector&lt;/span&gt; detectorOfType:&lt;span class=&quot;built_in&quot;&gt;CIDetectorTypeQRCode&lt;/span&gt; context:context options:@&amp;#123;&lt;span class=&quot;built_in&quot;&gt;CIDetectorAccuracy&lt;/span&gt;:&lt;span class=&quot;built_in&quot;&gt;CIDetectorAccuracyHigh&lt;/span&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIImage&lt;/span&gt; *image = [&lt;span class=&quot;built_in&quot;&gt;CIImage&lt;/span&gt; imageWith&lt;span class=&quot;built_in&quot;&gt;CGImage&lt;/span&gt;:qrimage.CGImage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *features = [detector featuresInImage:image];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIQRCodeFeature&lt;/span&gt; *feature = [features firstObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *result = feature.messageString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既然讲到要从相册获取照片，那么顺便把从相册获取照片也讲一下吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从相册获取照片主要用到的是&lt;code&gt;UIImagePickerController&lt;/code&gt;，这是苹果给我们分装好的一个相册选取的控制器。实现起来也是很简单的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)readerImage&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIImagePickerController&lt;/span&gt; *photoPicker = [[&lt;span class=&quot;built_in&quot;&gt;UIImagePickerController&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    photoPicker.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    photoPicker.sourceType = &lt;span class=&quot;built_in&quot;&gt;UIImagePickerControllerSourceTypePhotoLibrary&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    photoPicker.view.backgroundColor = [&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; whiteColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; presentViewController:photoPicker animated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; completion:&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当我们从照片库选择取了照片后要带调用&lt;code&gt;UIImagePickerController&lt;/code&gt;的代理方法获取选择的照片。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)imagePickerController:(&lt;span class=&quot;built_in&quot;&gt;UIImagePickerController&lt;/span&gt; *)picker didFinishPickingMediaWithInfo:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)info&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; dismissViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; completion:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;//code is here ...  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *srcImage = [info objectForKey:&lt;span class=&quot;built_in&quot;&gt;UIImagePickerControllerOriginalImage&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *result = [QRCScanner scQRReaderForImage:srcImage];&lt;span class=&quot;comment&quot;&gt;//调用上面讲过的方法对图片中的二维码进行处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.navigationController popViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;生成二维码&quot;&gt;&lt;a href=&quot;#生成二维码&quot; class=&quot;headerlink&quot; title=&quot;生成二维码&quot;&gt;&lt;/a&gt;生成二维码&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;生成二维码和从图片中读取二维码一样要用到&lt;code&gt;CoreImage&lt;/code&gt;,具体步骤如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *)makeQRCodeForString(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)string&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *text = string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *stringData = [text dataUsingEncoding: &lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//生成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;CIFilter&lt;/span&gt; *qrFilter = [&lt;span class=&quot;built_in&quot;&gt;CIFilter&lt;/span&gt; filterWithName:&lt;span class=&quot;string&quot;&gt;@&quot;CIQRCodeGenerator&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[qrFilter setValue:stringData forKey:&lt;span class=&quot;string&quot;&gt;@&quot;inputMessage&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[qrFilter setValue:&lt;span class=&quot;string&quot;&gt;@&quot;M&quot;&lt;/span&gt; forKey:&lt;span class=&quot;string&quot;&gt;@&quot;inputCorrectionLevel&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//二维码颜色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; *onColor = [&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; *offColor = [&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; blueColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//上色，如果只要白底黑块的QRCode可以跳过这一步&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;CIFilter&lt;/span&gt; *colorFilter = [&lt;span class=&quot;built_in&quot;&gt;CIFilter&lt;/span&gt; filterWithName:&lt;span class=&quot;string&quot;&gt;@&quot;CIFalseColor&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            			  keysAndValues:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        	 &lt;span class=&quot;string&quot;&gt;@&quot;inputImage&quot;&lt;/span&gt;,qrFilter.outputImage,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        	 &lt;span class=&quot;string&quot;&gt;@&quot;inputColor0&quot;&lt;/span&gt;,[&lt;span class=&quot;built_in&quot;&gt;CIColor&lt;/span&gt; colorWith&lt;span class=&quot;built_in&quot;&gt;CGColor&lt;/span&gt;:onColor.CGColor],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        	 &lt;span class=&quot;string&quot;&gt;@&quot;inputColor1&quot;&lt;/span&gt;,[&lt;span class=&quot;built_in&quot;&gt;CIColor&lt;/span&gt; colorWith&lt;span class=&quot;built_in&quot;&gt;CGColor&lt;/span&gt;:offColor.CGColor],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        	 &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//绘制&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;CIImage&lt;/span&gt; *qrImage = colorFilter.outputImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;CGSize&lt;/span&gt; size = &lt;span class=&quot;built_in&quot;&gt;CGSizeMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;CGImageRef&lt;/span&gt; cgImage = [[&lt;span class=&quot;built_in&quot;&gt;CIContext&lt;/span&gt; contextWithOptions:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;] create&lt;span class=&quot;built_in&quot;&gt;CGImage&lt;/span&gt;:qrImage 	fromRect:qrImage.extent];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;UIGraphicsBeginImageContext&lt;/span&gt;(size);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;CGContextRef&lt;/span&gt; context = &lt;span class=&quot;built_in&quot;&gt;UIGraphicsGetCurrentContext&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;CGContextSetInterpolationQuality&lt;/span&gt;(context, k&lt;span class=&quot;built_in&quot;&gt;CGInterpolationNone&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;CGContextScaleCTM&lt;/span&gt;(context, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1.0&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//生成的QRCode就是上下颠倒的,需要翻转一下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;CGContextDrawImage&lt;/span&gt;(context, &lt;span class=&quot;built_in&quot;&gt;CGContextGetClipBoundingBox&lt;/span&gt;(context), cgImage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *codeImage = &lt;span class=&quot;built_in&quot;&gt;UIGraphicsGetImageFromCurrentImageContext&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;UIGraphicsEndImageContext&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;CGImageRelease&lt;/span&gt;(cgImage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageWith&lt;span class=&quot;built_in&quot;&gt;CIImage&lt;/span&gt;:qrImage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然如果你不想写这个代码的话，你也可以使用一个轻量级的开源代码&lt;a href=&quot;https://github.com/fukuchi/libqrencode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libqrencode&lt;/a&gt;来帮你实现。它的使用非常简单,导入UIImage+MDQRCode这个扩展后，使用UIImage的类方法就可以调用了。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *)mdQRCodeForString:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)qrString size:(&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *)mdQRCodeForString:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)qrString size:(&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)size fillColor:(&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; *)fillColor;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;QRCScanner&quot;&gt;&lt;a href=&quot;#QRCScanner&quot; class=&quot;headerlink&quot; title=&quot;QRCScanner&quot;&gt;&lt;/a&gt;QRCScanner&lt;/h3&gt;&lt;p&gt;如果你连上面的代码一点儿都不想写，想一句话就集成扫描功能，你可以使用我封装的&lt;code&gt;QRCScanner&lt;/code&gt;,地址点&lt;a href=&quot;https://github.com/zhangfeidev/QRCScanner&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;用第三方ZBar，ZXing是导入有问题？或者是编译有问题？使用自带的就不用担心这些问题，而且是秒扫哦！如果你觉得我的文章对你有帮助，请随意打赏！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/cfaa8811jw1ey7veld0soj205k05l74a.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;扫一扫这个功能我们并不陌生，微信QQ加好友扫一扫，路边搞推广的扫一扫，吃饭付钱扫一扫。看来这个扫一扫应用的地方还真不少啊！打开手机看了看安装的APP,社交类APP有扫一扫，支付类的APP有扫一扫，连浏览器都有扫一扫。看来这个扫一扫不可小视！说不定哪天在你的项目中你的boss就要你给他加个扫一扫的功能呢！对于iOS开发要想做扫一扫这个功能，并不是很难，我们需要做的就是处理二维码(QRCode)而已。在iOS7之前需要借助第三方库ZBar和ZXing。在iOS7以后用自带API就能轻松搞定。不用在项目中导入臃肿的第三方库和担心编译出问题了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="二维码" scheme="zhangfei.tk/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS的本地推送和远程推送</title>
    <link href="zhangfei.tk/2015/10/12/%E6%8E%A8%E9%80%81/"/>
    <id>zhangfei.tk/2015/10/12/推送/</id>
    <published>2015-10-11T16:00:00.000Z</published>
    <updated>2016-03-23T05:04:57.000Z</updated>
    
    <content type="html">&lt;p&gt;推送也叫推送通知，是在iOS 3.0以后被引入的功能。是当程序没有启动或不在前台运行时，告诉用户有新消息的一种途径。有远程推送和本地推送之分。本地推送就是由应用程序发起的推送通知，不经过服务器。远程推送是由服务器发送的消息经过苹果的APNS（Apple Push Notification Service）服务远程推送给设备。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;关于推送&quot;&gt;&lt;a href=&quot;#关于推送&quot; class=&quot;headerlink&quot; title=&quot;关于推送&quot;&gt;&lt;/a&gt;关于推送&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;推送也叫推送通知，是在iOS 3.0以后被引入的功能。是当程序没有启动或不在前台运行时，告诉用户有新消息的一种途径。有远程推送和本地推送之分。本地推送就是由应用程序发起的推送通知，不经过服务器。远程推送是由服务器发送的消息经过苹果的APNS（Apple Push Notification Service）服务远程推送给设备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本地推送&quot;&gt;&lt;a href=&quot;#本地推送&quot; class=&quot;headerlink&quot; title=&quot;本地推送&quot;&gt;&lt;/a&gt;本地推送&lt;/h2&gt;&lt;p&gt;本地推送不依赖服务器，只需要在程序里面写好触发推送通知的逻辑就可以了。添加一个本地通知的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UILocalNotification&lt;/span&gt; *localNotification = [[&lt;span class=&quot;built_in&quot;&gt;UILocalNotification&lt;/span&gt; alloc] init];&lt;span class=&quot;comment&quot;&gt;//初始化本地通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (localNotification != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; *now = [&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       localNotification.fireDate = [now dateByAddingTimeInterval:&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//15秒后通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       localNotification.repeatInterval = k&lt;span class=&quot;built_in&quot;&gt;CFCalendarUnitHour&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//循环次数，kCFCalendarUnitHour一小时一次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       localNotification.timeZone = [&lt;span class=&quot;built_in&quot;&gt;NSTimeZone&lt;/span&gt; defaultTimeZone];&lt;span class=&quot;comment&quot;&gt;//UILocalNotification激发时间是否根据时区改变而改变&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       localNotification.applicationIconBadgeNumber += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//应用的红色数字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       localNotification.soundName = &lt;span class=&quot;built_in&quot;&gt;UILocalNotificationDefaultSoundName&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//声音，可以换成自己的，如：alarm.soundName = @&quot;myMusic.caf&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       localNotification.alertBody = &lt;span class=&quot;string&quot;&gt;@&quot;我是通知内容&quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//提示信息 弹出提示框&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       localNotification.alertAction = &lt;span class=&quot;string&quot;&gt;@&quot;打开&quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//解锁按钮文字，就是在锁屏情况下有一个‘滑动来XXX’,这儿的XXX就是这里所设置的alertAction。如果不设置就是@“查看”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       localNotification.hasAction = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//是否显示额外的按钮，为no时alertAction的设置不起作用，hasAction默认是YES&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;//通知的额外信息，不会展示出来，是用来判断通知是哪一条的额外信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *infoDict = [&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; dictionaryWithObject:&lt;span class=&quot;string&quot;&gt;@&quot;xiaofei&quot;&lt;/span&gt; forKey:&lt;span class=&quot;string&quot;&gt;@&quot;birthday&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       localNotification.userInfo = infoDict;&lt;span class=&quot;comment&quot;&gt;//添加额外的信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [[&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; sharedApplication] scheduleLocalNotification:localNotification];&lt;span class=&quot;comment&quot;&gt;//添加本地通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果想要取消本地推送，可以用下面的代码进行取消，既可以通过获取userInfo信息取消特定的消息，也可以取消全部的消息。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; *app = [&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; sharedApplication];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;* localNotifications = [app scheduledLocalNotifications];&lt;span class=&quot;comment&quot;&gt;//获取当前应用所有的通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (localNotifications) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;UILocalNotification&lt;/span&gt;* notification &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; localNotifications) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *dic = notification.userInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (dic) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt;* key = [dic objectForKey:&lt;span class=&quot;string&quot;&gt;@&quot;key&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([key isEqualToString:&lt;span class=&quot;string&quot;&gt;@&quot;name&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;//取消推送 （指定一个取消）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    [app cancelLocalNotification:notification];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//取消当前应用所有的推送&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//[app cancelAllLocalNotifications];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;收到消息后该如何处理呢？不管是在程序正在使用或者退出的状态下，都是通过UIApplication的代理方法进行处理，该方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)application:(&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; *)application didReceiveLocalNotification:(&lt;span class=&quot;built_in&quot;&gt;UILocalNotification&lt;/span&gt; *)notification &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//处理收到的通知...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    application.applicationIconBadgeNumber = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//应用程序角标清零&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;远程推送&quot;&gt;&lt;a href=&quot;#远程推送&quot; class=&quot;headerlink&quot; title=&quot;远程推送&quot;&gt;&lt;/a&gt;远程推送&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;iOS的远程通知和安卓不一样，iOS要通过苹果公司提供的推送服务(APNS)才能把想要推送的消息从服务器那边推送到iPhone设备上。因此还得和苹果的APNS打交道。要在程序中添加推送服务需要配置不少东西，具体步骤如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给应用程序的App ID添加Push Notifications服务–&amp;gt;配置对应的证书–&amp;gt;配置对应Provisioning Profiles文件–&amp;gt;获取Device Token–&amp;gt;服务器端通过deviceToken和APNS建立SSL连接–&amp;gt;服务器端给APNS服务器发送推送消息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置Push Notifications服务和相应证书请参考&lt;a href=&quot;http://www.jianshu.com/p/074bc6fffd0e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;教你一步一步获取App ID&lt;/a&gt;，配置文件Provisioning Profiles文件请移步&lt;a href=&quot;http://www.jianshu.com/p/6aa72b177daf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;教你一步一步获取Provisioning Profiles&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;获取deviceToken需要在程序里面用代码来解决。首先注册远程推送通知，通过UIApllication的代理方法获取，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([[[&lt;span class=&quot;built_in&quot;&gt;UIDevice&lt;/span&gt; currentDevice] systemVersion] floatValue] &amp;gt;= &lt;span class=&quot;number&quot;&gt;8.0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UIUserNotificationType&lt;/span&gt; myTypes = &lt;span class=&quot;built_in&quot;&gt;UIRemoteNotificationTypeBadge&lt;/span&gt; | &lt;span class=&quot;built_in&quot;&gt;UIRemoteNotificationTypeAlert&lt;/span&gt; | &lt;span class=&quot;built_in&quot;&gt;UIRemoteNotificationTypeSound&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UIUserNotificationSettings&lt;/span&gt; *settings = [&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationSettings&lt;/span&gt; settingsForTypes:myTypes categories:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [[&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; sharedApplication] registerUserNotificationSettings:settings];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIRemoteNotificationType&lt;/span&gt; myTypes = &lt;span class=&quot;built_in&quot;&gt;UIRemoteNotificationTypeBadge&lt;/span&gt;|&lt;span class=&quot;built_in&quot;&gt;UIRemoteNotificationTypeAlert&lt;/span&gt;|&lt;span class=&quot;built_in&quot;&gt;UIRemoteNotificationTypeSound&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; sharedApplication] registerForRemoteNotificationTypes:myTypes];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在iOS8以后还要添加下面的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#ifdef __IPHONE_8_0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)application:(&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; *)application didRegisterUserNotificationSettings:(&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationSettings&lt;/span&gt; *)notificationSettings&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [application registerForRemoteNotifications];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注册成功以后通过UIApplication的代理方法获取deviceToken。获取deviceToken的格式是这样的：&lt;code&gt;75e84eed c0451b39 5d8eec91 03154347 3ad56aee 97f8f565 9f027842 b78f8c77&lt;/code&gt;,并且要注意把deviceToken给后台的时候要去掉两边的尖括号和中间的空格。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)application:(&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; *)application didRegisterForRemoteNotificationsWithDeviceToken:(&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *)deviceToken&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;deviceToken:%@&quot;&lt;/span&gt;,deviceToken);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是如果注册远程通知失败后会调用下面的代理方法。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)application:(&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; *)application didFailToRegisterForRemoteNotificationsWithError:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *)error&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;注册失败，错误是：%@&quot;&lt;/span&gt;,error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;程序正在使用或者退出的状态下，都会调用UIApplication的代理方法进行处理，该方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)application:(&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; *)application didReceiveRemoteNotification:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)userInfo&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//处理通知...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Receive remote notification : %@&quot;&lt;/span&gt;,userInfo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    application.applicationIconBadgeNumber = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;推送远程消息&quot;&gt;&lt;a href=&quot;#推送远程消息&quot; class=&quot;headerlink&quot; title=&quot;推送远程消息&quot;&gt;&lt;/a&gt;推送远程消息&lt;/h2&gt;&lt;p&gt;如果写demo的话，可以用&lt;a href=&quot;https://github.com/shaojiankui/SmartPush&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SmartPush&lt;/a&gt;进行模拟测试。想了解SmartPush的详细使用请移步到&lt;a href=&quot;http://www.jianshu.com/p/23b745f8a980&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用SmartPush进行iOS远程推送测试&lt;/a&gt;。如果你会Python的话，你可以参考一下这个&lt;a href=&quot;https://github.com/zhangfeidev/iOSTools/tree/master/pushPythonCode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;代码&lt;/a&gt;来推送消息。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;关于推送流程可以&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考苹果官方文档&lt;/a&gt;,那里有详细的流程解释。&lt;/li&gt;
&lt;li&gt;在进行推送处理时要注意点击程序图标进入程序和点击消息进入程序是不同的，前者不会调用代理方法，需要从&lt;code&gt;didFinishLaunchingWithOptions:&lt;/code&gt;方法的参数`launchOptions进行判断处理。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;推送也叫推送通知，是在iOS 3.0以后被引入的功能。是当程序没有启动或不在前台运行时，告诉用户有新消息的一种途径。有远程推送和本地推送之分。本地推送就是由应用程序发起的推送通知，不经过服务器。远程推送是由服务器发送的消息经过苹果的APNS（Apple Push Notification Service）服务远程推送给设备。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Objective-C" scheme="zhangfei.tk/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>从不可变的NSString谈起之const</title>
    <link href="zhangfei.tk/2015/09/14/%E4%BB%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84NSString%E5%92%8C%E5%8F%AF%E5%8F%98%E7%9A%84NSMultableString%E8%B0%88%E8%B5%B7%E4%B9%8Bconst/"/>
    <id>zhangfei.tk/2015/09/14/从不可变的NSString和可变的NSMultableString谈起之const/</id>
    <published>2015-09-14T03:11:11.000Z</published>
    <updated>2016-03-23T04:52:46.000Z</updated>
    
    <content type="html">&lt;p&gt;今天在项目中多出发现使用const来修饰NSString。平时我自己并没有这样用过，于是就决定好好研究一番。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;1-谈谈NSString的不可变&quot;&gt;&lt;a href=&quot;#1-谈谈NSString的不可变&quot; class=&quot;headerlink&quot; title=&quot;1.谈谈NSString的不可变&quot;&gt;&lt;/a&gt;1.谈谈NSString的不可变&lt;/h3&gt;&lt;p&gt;在学习基础语法的时候，我们知道当字符串不变的时候我们用&lt;code&gt;NSString&lt;/code&gt;，可变字符串用&lt;code&gt;NSMultableString&lt;/code&gt;。&lt;code&gt;NSString&lt;/code&gt;和&lt;code&gt;NSMutableString&lt;/code&gt;的可变与不可变,主要区分的标准是,它们本身是不是可以变,可变的一般都能增,删,改,而不可变的方法主要是创建,查看,得到元素个数或者长度等等;&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name = &lt;span class=&quot;string&quot;&gt;@&quot;xiaofei&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name = &lt;span class=&quot;string&quot;&gt;@&quot;zhangfei&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;name is %@&quot;&lt;/span&gt;,name); &lt;span class=&quot;comment&quot;&gt;//结果是：name is zhangfei&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然&lt;code&gt;NSString&lt;/code&gt;内容本身是不可变，即不可以对其本身增，删，改等，但是&lt;code&gt;NSString *&lt;/code&gt;值的指针可以改变指向的。虽然内容没有改变，但是对系统常量这一类值，还是很危险的呀。如果需要一个既不要内容改变也不要指针改变的&lt;code&gt;NSString&lt;/code&gt;类型的常量该怎么办呢？这时候&lt;code&gt;const&lt;/code&gt;就派上用场了。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; *name = &lt;span class=&quot;string&quot;&gt;@&quot;xiaofei&quot;&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//这时候name的内容和指针都不能被改变了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-谈谈const&quot;&gt;&lt;a href=&quot;#2-谈谈const&quot; class=&quot;headerlink&quot; title=&quot;2.谈谈const&quot;&gt;&lt;/a&gt;2.谈谈const&lt;/h3&gt;&lt;p&gt;const是OC中的一个关键字，也就是constant，常量的意思。 即const修饰的变量或者指针什么的都有‘常量’的味道了。在什么时候用呢？当我们想全局共用一些数据时就可以用const。当然你会说还可以用宏定义呀，当然，他们之间的点点滴滴我们后面谈，线看看const的基本用法吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义常量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; dataType constData = value;&lt;span class=&quot;comment&quot;&gt;//const修饰的类型为dataType的变量value不可变.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;适合用于全局不可变的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在指针中使用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;@&quot;xiaofei&quot;&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//1.name不能被修改，*name能被修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; *name = &lt;span class=&quot;string&quot;&gt;@&quot;xiaofei&quot;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;//2.name能被修改，*name不能被修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name = &lt;span class=&quot;string&quot;&gt;@&quot;xiaofei&quot;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;//3.name能被修改，*name不能被修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在苹果文档中经常出现1的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在函数中使用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* A(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* str);       &lt;span class=&quot;comment&quot;&gt;//传指针参数前添加const，str指向的内容被修饰为常量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* A(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ClassType &amp;amp;obj);  &lt;span class=&quot;comment&quot;&gt;//传引用参数前添加const，obj在函数体内被修饰为常量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;3-什么时候使用const&quot;&gt;&lt;a href=&quot;#3-什么时候使用const&quot; class=&quot;headerlink&quot; title=&quot;3.什么时候使用const?&quot;&gt;&lt;/a&gt;3.什么时候使用const?&lt;/h3&gt;&lt;p&gt;在谈论const的时候，人们总是把它和宏相提并论，我们来看看它们二者的区别吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宏：只是在预处理器里进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化。&lt;/li&gt;
&lt;li&gt;const修饰作为常量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以根据const修饰的位置设定能否修改，在编译阶段会执行类型检查。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;const的正确使用性能要高于宏，const可以进行指针比较。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;文章末尾&quot;&gt;&lt;a href=&quot;#文章末尾&quot; class=&quot;headerlink&quot; title=&quot;文章末尾&quot;&gt;&lt;/a&gt;文章末尾&lt;/h2&gt;&lt;p&gt;一般在项目中，都会把全局常量写在独立的文件中，然后把该文件写在预编译文件中去，const的学习 就这样啦，如果有什么更好的知识，欢迎留言，祝大家玩得高兴！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天在项目中多出发现使用const来修饰NSString。平时我自己并没有这样用过，于是就决定好好研究一番。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Objective-C" scheme="zhangfei.tk/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的多线程</title>
    <link href="zhangfei.tk/2015/08/29/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>zhangfei.tk/2015/08/29/iOS中的多线程/</id>
    <published>2015-08-29T03:11:11.000Z</published>
    <updated>2016-03-23T04:55:25.000Z</updated>
    
    <content type="html">&lt;p&gt;多线程可以将一个程序划分成多个任务，他们彼此独立的工作，以方便有效的使用处理器和用户的时间。因此，在iOS编程中，多线程是非常有必要的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;准备知识，如果不清楚的请自行google：&lt;code&gt;进程&lt;/code&gt;, &lt;code&gt;线程&lt;/code&gt;, &lt;code&gt;进程和线程的关系&lt;/code&gt;, &lt;code&gt;串行&lt;/code&gt;, &lt;code&gt;并行&lt;/code&gt;, &lt;code&gt;主线程&lt;/code&gt;, &lt;code&gt;子线程&lt;/code&gt;, &lt;code&gt;多线程&lt;/code&gt;, &lt;code&gt;主线程和子线程的关系&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上面的准备知识中需要注意一下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iOS程序中，程序运行自动创建的那条线程就是主线程，也叫UI线程。&lt;/li&gt;
&lt;li&gt;iOS程序中，主线程的主要任务是处理UI事件，显示和刷新UI，因此与这些无关的事情就别再主线程中做了。&lt;/li&gt;
&lt;li&gt;耗时的操作放到子线程中，因为耗时的操作放到主线程中会卡住UI，严重影响UI的流畅度，给用户一种卡的“坏”体验。&lt;/li&gt;
&lt;li&gt;在iOS中不要同时开很多线程，同时一般是1–3条，不要超过5条。&lt;/li&gt;
&lt;li&gt;子线程也叫后台线程，异步线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;iOS中多线程的优缺点&quot;&gt;&lt;a href=&quot;#iOS中多线程的优缺点&quot; class=&quot;headerlink&quot; title=&quot;iOS中多线程的优缺点&quot;&gt;&lt;/a&gt;iOS中多线程的优缺点&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;优点：1.能适当提高程序的执行效率；2.能适当提高资源利用率。
缺点：1.开启线程需要一定的内存，主线程1M,子线程512KB，开启大量的线程会占用大量的内存，降低程序的性能。2.线程越多，CPU调度线程的开销就越大。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;iOS中多线程的实现方案&quot;&gt;&lt;a href=&quot;#iOS中多线程的实现方案&quot; class=&quot;headerlink&quot; title=&quot;iOS中多线程的实现方案&quot;&gt;&lt;/a&gt;iOS中多线程的实现方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Pthreads&lt;/li&gt;
&lt;li&gt;NSThread&lt;/li&gt;
&lt;li&gt;GCD&lt;/li&gt;
&lt;li&gt;NSOperation &amp;amp; NSOperationQueue&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;其对比如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;技术方案&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;th&gt;语言&lt;/th&gt;
&lt;th&gt;线程生命周期&lt;/th&gt;
&lt;th&gt;使用频率&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Pthreads&lt;/td&gt;
&lt;td&gt;一套通用的多线程API；适用于Unix/Linux/Mac/Windows等系统；跨平台/可移植；使用难度大&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;程序员管理&lt;/td&gt;
&lt;td&gt;几乎不用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NSThread&lt;/td&gt;
&lt;td&gt;使用更加面向对象；简单易用，可直接操作线程对象&lt;/td&gt;
&lt;td&gt;OC&lt;/td&gt;
&lt;td&gt;程序员管理&lt;/td&gt;
&lt;td&gt;偶尔使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GCD&lt;/td&gt;
&lt;td&gt;旨在取代NSThread ；充分利用设备多核&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;自动管理&lt;/td&gt;
&lt;td&gt;经常使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NSOperation&lt;/td&gt;
&lt;td&gt;基于GCD，对GCD的封装；比GCD更加面向对象；比GCD多了一些简单实用的功能&lt;/td&gt;
&lt;td&gt;OC&lt;/td&gt;
&lt;td&gt;自动管理&lt;/td&gt;
&lt;td&gt;经常使用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从上面的表格中便知道要重点掌握的是GCD和NSOperation，因此我对前面2种线程技术没有过多的篇幅将解，想要了解的请自行Google吧！&lt;/p&gt;
&lt;h2 id=&quot;Pthreads&quot;&gt;&lt;a href=&quot;#Pthreads&quot; class=&quot;headerlink&quot; title=&quot;Pthreads&quot;&gt;&lt;/a&gt;Pthreads&lt;/h2&gt;&lt;p&gt;POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。基于C语言，使用起来自然不是那么的容易，且看代码。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//首先要导入pthread类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//创建线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pthread_t myRestrict;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pthread_create(&amp;amp;myRestrict, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, run, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//该函数内的代码会在myRestrict这个线程中执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *run(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;当前线程是：%@&quot;&lt;/span&gt;,[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码只是开启了一个线程，对于线程的周期还是需要我们自己去维护的。如用&lt;code&gt;pthread_exit()&lt;/code&gt;函数终止线程。总之一句话，不做死就不会死。iOS都用后面更好用的了，且往下看。&lt;/p&gt;
&lt;h2 id=&quot;NSThread&quot;&gt;&lt;a href=&quot;#NSThread&quot; class=&quot;headerlink&quot; title=&quot;NSThread&quot;&gt;&lt;/a&gt;NSThread&lt;/h2&gt;&lt;p&gt;这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便。但是，它的生命周期还是需要我们手动管理，所以这套方案也是偶尔用用。用它的地方就是在调试的时候，比较常用的方法有：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//取消线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)cancel;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//启动线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)start;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//判断某个线程的状态的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;, getter=isExecuting) &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; executing;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;, getter=isFinished) &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; finished;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;, getter=isCancelled) &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; cancelled;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置和获取线程名字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setName:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//获取当前线程信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; *)currentThread;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//获取主线程信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; *)mainThread;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使当前线程暂停一段时间，或者暂停到某个时刻&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sleepForTimeInterval:(&lt;span class=&quot;built_in&quot;&gt;NSTimeInterval&lt;/span&gt;)time;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sleepUntilDate:(&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; *)date;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用NSThread创建的线程也需要手动管理线程周期，但是比起Pthreads好多了，有了面向对象的特征。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;方式一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//创建线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; *thread = [[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; alloc]initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(run) object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//run函数里面的代码在thread这个线程中执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread.name = &lt;span class=&quot;string&quot;&gt;@&quot;线程一&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//开启线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[thread start];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;方式二&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//自动启动,不需要写[thread start];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; detachNewThreadSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(run:) toTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; withObject:&lt;span class=&quot;string&quot;&gt;@&quot;这是传递的参数&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;方式三&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//自动启动,不需要写[thread start];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//现在苹果已经认为这种方式不安全了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; performSelectorInBackground:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(run) withObject:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h2&gt;&lt;p&gt;GCD全名Grand Central Dispatch(牛逼的中枢调度器)，基于C语言，它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。所以使用起来非常的爽，所以在上面的表格中，写的是经常使用。GCD是基于队列和任务来进行的。所以有必要了解这两个概念，下面是简单的说明.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任务：简单的说就是要做的事情，在GCD中一般是block中的代码。执行方式有同步和异步。&lt;br&gt;队列：用于存放队列的，GCD中的队列遵循&lt;code&gt;FIFO&lt;/code&gt;（先进先出）的原则，队列分为串行队列和并行队列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在使用GCD前，先来看一个表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;同步方式&lt;/th&gt;
&lt;th&gt;全局并发队列&lt;/th&gt;
&lt;th&gt;手动创建的串行队列&lt;/th&gt;
&lt;th&gt;主队列&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同步（sync）&lt;/td&gt;
&lt;td&gt;没有开启新的线程；串行执行任务&lt;/td&gt;
&lt;td&gt;没有开启新的线程；串行执行任务&lt;/td&gt;
&lt;td&gt;没有开启新的线程；串行执行任务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;异步（async）&lt;/td&gt;
&lt;td&gt;有开启新的线程；并发执行任务&lt;/td&gt;
&lt;td&gt;有开启新的线程；串行执行任务&lt;/td&gt;
&lt;td&gt;没有开启新的线程；串行执行任务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;主队列（main_queue）是一个比较特殊的队列，放到main_queue中的任务都会被自动放到主线程中执行。并且主队列是串行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用GCD首先要创建一个队列，然后把任务扔到队列中即可。下面是队列的创建方式：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//串行队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_queue_t&lt;/span&gt; queue = dispatch_get_main_queue();&lt;span class=&quot;comment&quot;&gt;//主队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_queue_t&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;tk.bourne.testQueue&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_queue_t&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;tk.bourne.testQueue&quot;&lt;/span&gt;, DISPATCH_QUEUE_SERIAL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//并行队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_queue_t&lt;/span&gt; queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个全局并发队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_queue_t&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;tk.bourne.testQueue&quot;&lt;/span&gt;, DISPATCH_QUEUE_CONCURRENT);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来就是创建任务啦,下面的代码模拟了一个异步下载图片，并且回到主线程刷新UI的任务。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//开启一个异步任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_async&lt;/span&gt;(queue, ^&amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSlog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;开启一个异步任务!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//开启一个同步任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_sync&lt;/span&gt;(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;NSlog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;开启一个同步任务，还不如在主线程中执行呢！何必多此一举！&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` objc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;## NSOperation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSOperation&lt;/span&gt; 是苹果公司对 GCD 的封装，完全面向对象,因此可以用面向对象的一些东西，用起来也是非常好用的。性能方面，对比GCD来说相对差一些，毕竟在GCD上面封装了一层嘛。在使用&lt;span class=&quot;built_in&quot;&gt;NSOperation&lt;/span&gt;之前必须还要知道&lt;span class=&quot;built_in&quot;&gt;NSOperationQueue&lt;/span&gt;这个东西，&lt;span class=&quot;built_in&quot;&gt;NSOperation&lt;/span&gt;和&lt;span class=&quot;built_in&quot;&gt;NSOperationQueue&lt;/span&gt;分别对应这GCD的任务和队列的概念。即苹果把任务封装成了&lt;span class=&quot;built_in&quot;&gt;NSOperation&lt;/span&gt;对象，一个任务就是一个&lt;span class=&quot;built_in&quot;&gt;NSOperation&lt;/span&gt;对象;将队列封装成了一个&lt;span class=&quot;built_in&quot;&gt;NSOperationQueue&lt;/span&gt;对象。但是在使用的时候我们需要注意下面这个问题：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&lt;span class=&quot;built_in&quot;&gt;NSOperation&lt;/span&gt;只是一个抽象类，所以不能封装任务。但它有&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;个子类用于封装任务。分别是：&lt;span class=&quot;built_in&quot;&gt;NSInvocationOperation&lt;/span&gt;和&lt;span class=&quot;built_in&quot;&gt;NSBlockOperation&lt;/span&gt;。创建一个Operation对象后，需要调用start方法来启动任务，它会默认在当前队列同步执行。如果想要在中途取消一个任务，只需要调用其cancel方法即可。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;用&lt;span class=&quot;built_in&quot;&gt;NSInvocationOperation&lt;/span&gt;（&lt;span class=&quot;built_in&quot;&gt;NSInvocationOperation&lt;/span&gt; 不是一个类型安全的类，在iOS8&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;的API中已经移除了该类，详情看[这里](https:&lt;span class=&quot;comment&quot;&gt;//developer.apple.com/library/ios/releasenotes/General/iOS81APIDiffs/modules/Foundation.html),因此可以考虑不用它了）创建一个任务：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` objc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//创建NSInvocationOperation对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSInvocationOperation&lt;/span&gt; *operation = [[&lt;span class=&quot;built_in&quot;&gt;NSInvocationOperation&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(run) object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[operation start];&lt;span class=&quot;comment&quot;&gt;//开始执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;常用的还是用NSBlockOperation（还是喜欢block，^_^）：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//创建NSBlockOperation对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSBlockOperation&lt;/span&gt; *operation = [&lt;span class=&quot;built_in&quot;&gt;NSBlockOperation&lt;/span&gt; blockOperationWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, [&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[operation start];&lt;span class=&quot;comment&quot;&gt;//开始执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;关于多线程，还有很多高深的知识，想要探究一下的话，下面是一些我参考的知识。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dreamingwish.com/article/ios-multi-threaded-programming-guide-directory.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;梦维将多线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://objcio.cn/issue-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OBJC中国讲的线程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;多线程可以将一个程序划分成多个任务，他们彼此独立的工作，以方便有效的使用处理器和用户的时间。因此，在iOS编程中，多线程是非常有必要的。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Objective-C" scheme="zhangfei.tk/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C中那些关键字</title>
    <link href="zhangfei.tk/2015/08/26/Objective-C%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%9D%E7%95%99%E5%AD%97/"/>
    <id>zhangfei.tk/2015/08/26/Objective-C中那些不常用的保留字/</id>
    <published>2015-08-26T03:11:11.000Z</published>
    <updated>2016-03-23T04:58:21.000Z</updated>
    
    <content type="html">&lt;p&gt;今天在网上看了一篇讲Objective-C关键字的文章，发现自己有一些关键字几乎没有用过，因此在此写文记录一下学习心得。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于Objective-C中的关键字，在Steffen Itterheim的&lt;a href=&quot;http://www.learn-cocos2d.com/2011/10/complete-list-objectivec-20-compiler-directives&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一篇博文&lt;/a&gt;中有不错的讲解，在Objective-C2.0中有一下关键字：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@class&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@defs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@protocol&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;required&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;optional&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;public&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;package&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;protected&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;private&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;synthesize&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;dynamic&lt;/span&gt; @&lt;span class=&quot;title&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;@try&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;@catch&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;@finally&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@synchronized&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt; @encode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@compatibility_alias&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@”string”&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这些关键字中，&lt;code&gt;@defs&lt;/code&gt;,&lt;code&gt;@dynamic&lt;/code&gt;,&lt;code&gt;@encode&lt;/code&gt;,&lt;code&gt;@compatibility_alias&lt;/code&gt;不是很常用，而对&lt;code&gt;@class&lt;/code&gt;,&lt;code&gt;@throw&lt;/code&gt;,&lt;code&gt;@try&lt;/code&gt;,&lt;code&gt;@catch&lt;/code&gt;,&lt;code&gt;@finally&lt;/code&gt;,&lt;code&gt;@synchronized&lt;/code&gt;,&lt;code&gt;@autoreleasepool&lt;/code&gt;,&lt;code&gt;@selector&lt;/code&gt;常用并且很重要的我也会做一些记录，就当是温故而知新吧。&lt;/p&gt;
&lt;h2 id=&quot;defs&quot;&gt;&lt;a href=&quot;#defs&quot; class=&quot;headerlink&quot; title=&quot;@defs&quot;&gt;&lt;/a&gt;@defs&lt;/h2&gt;&lt;p&gt;返回一个 Objective-C 类的布局。比如，定义一个与 NSObject 有相同布局的 struct，你只需要这样：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  @defs(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们一般是不会用到这个关键字的，除非在做一些底层操作和实现的时候才会用到。&lt;/p&gt;
&lt;h2 id=&quot;dynamic&quot;&gt;&lt;a href=&quot;#dynamic&quot; class=&quot;headerlink&quot; title=&quot;@dynamic&quot;&gt;&lt;/a&gt;@dynamic&lt;/h2&gt;&lt;p&gt;&lt;code&gt;@dynamic&lt;/code&gt;是相对于&lt;code&gt;@synthesize&lt;/code&gt;的，它们用样用于修饰&lt;code&gt;@property&lt;/code&gt;，用于生成对应的的&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;方法。但是&lt;code&gt;@dynamic&lt;/code&gt;表示这个成员变量的&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;方法并不是直接由编译器生成，而是手工生成或者运行时生成。具体用法是在实现文件中，即原来写&lt;code&gt;@synthesize&lt;/code&gt;的地方用&lt;code&gt;@dynamic&lt;/code&gt;修饰，这样的话，就不会自动生成&lt;code&gt;setter&lt;/code&gt;和&lt;code&gt;getter&lt;/code&gt;方法了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在Xcode4.4以后只要用@property修饰的属性编译器都会自动生成对应的&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;方法，即不用手动@synthesize生成了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassName&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@dynamic&lt;/span&gt; anotherProperty;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;encode&quot;&gt;&lt;a href=&quot;#encode&quot; class=&quot;headerlink&quot; title=&quot;@encode&quot;&gt;&lt;/a&gt;@encode&lt;/h2&gt;&lt;p&gt;返回一个类型的类型编码，具体的请看&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;compatibility-alias&quot;&gt;&lt;a href=&quot;#compatibility-alias&quot; class=&quot;headerlink&quot; title=&quot;@compatibility_alias&quot;&gt;&lt;/a&gt;@compatibility_alias&lt;/h2&gt;&lt;p&gt;@compatibility_alis是用于给一个类设置一个别名。这样就不用重构以前的类文件就可以用新的名字来替代原有名字。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//现在你就可以使用MyUICollectionVC这个名字替代UICollectionViewController了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@compatibility_alias &lt;span class=&quot;built_in&quot;&gt;UICollectionViewController&lt;/span&gt; My&lt;span class=&quot;built_in&quot;&gt;UICollectionVC&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;class&quot;&gt;&lt;a href=&quot;#class&quot; class=&quot;headerlink&quot; title=&quot;@class&quot;&gt;&lt;/a&gt;@class&lt;/h2&gt;&lt;p&gt;为了减少由依赖关系引起的重新编译所带的影响，&lt;code&gt;Objective-C&lt;/code&gt;引入了关键字@class来告诉编译器：这是一个类，所以我只需要通过指针来引用它。它并不需要知道关于这个类的更多信息，只要了解它是通过指针引用即可。有的时候，&lt;code&gt;@interface&lt;/code&gt;声明会在属性中引用外部类或者作为参数类型。而不是给每个类添加&lt;code&gt;#import&lt;/code&gt;语句，在头文件使用前置声明，并且在&lt;code&gt;implementation&lt;/code&gt;中引入它们是很好的做法。这样做编译时间更短，循环引用的机会更少。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE:和import的对比，一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.需要详细了解class和import的区别请到&lt;a href=&quot;http://stackoverflow.com/questions/322597/class-vs-import&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这儿&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//如果ClassA.h中仅需要声明一个ClassB的指针，那么就可以在ClassA.h中声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@ClassB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ClassB *pointer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//如果在implementation中要用到ClassB类的实体变量或者方法的话就需要import了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;throw-try-catch-finally&quot;&gt;&lt;a href=&quot;#throw-try-catch-finally&quot; class=&quot;headerlink&quot; title=&quot;@throw,@try,@catch,@finally&quot;&gt;&lt;/a&gt;@throw,@try,@catch,@finally&lt;/h2&gt;&lt;p&gt;在其他语言中用try/catch/finally块来捕获异常，如java。Objective-C主要通过NSError来沟通意想不到的异常状态。凡是也能像java那样使用@throw,@try,@catch,@finally这些关键字构成的块来捕获异常。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE:关于关键字@try，@catch，@thorw，@finally。当代码有可能出现异常时，我们把他放到@try语句块中。@catch()块包含了处理@try块里的抛出的异常的逻辑。无论异常是否发生，@finally块里面的语句都会执行。如果直接使用@throw块来抛出异常，这个异常本质上是一个OC的对象。咱们可以使用NSException对象，但是不局限于他们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//代码来自Apple官方文档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// code that throws an exception&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@catch&lt;/span&gt; (CustomException *ce) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// most specific type&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// handle exception ce&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@catch&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NSException&lt;/span&gt; *ne) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// less specific type&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// do whatever recovery is necessary at his level&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// rethrow the exception so it&#39;s handled at a higher level&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@throw&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@catch&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; ue) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// least specific type&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// code that handles this exception&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// perform tasks necessary whether exception occurred or not&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一些讲异常处理的文章： &lt;a href=&quot;http://blog.csdn.net/totogo2010/article/details/7713793&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objective-C语法之异常处理&lt;/a&gt;&lt;br&gt;，&lt;a href=&quot;http://www.cnblogs.com/GarveyCalvin/p/4182861.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS捕获异常，常用的异常处理方法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;@synchronized&quot;&gt;&lt;/a&gt;@synchronized&lt;/h2&gt;&lt;p&gt;@synchronized，代表这个方法加锁, 相当于不管哪一个线程（例如线程A），运行到这个方法时,都要检查有没有其它线程例如B正在用这个方法，有的话要等正在使用synchronized方法的线程B运行完这个方法后再运行此线程A,没有的话,直接运行。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)criticalMethod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@synchronized&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//这里的代码会被加锁保护;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;@synchronized涉及到了一些线程同步的知识，如果想要详细了解线程同步，请到&lt;a href=&quot;http://www.dreamingwish.com/article/the-ios-multithreaded-programming-guide-4-thread-synchronization.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;autoreleasepool&quot;&gt;&lt;a href=&quot;#autoreleasepool&quot; class=&quot;headerlink&quot; title=&quot;@autoreleasepool&quot;&gt;&lt;/a&gt;@autoreleasepool&lt;/h2&gt;&lt;p&gt;@autoreleasepool叫自动释放池，是OC里面的一种内存回收机制，一般可以将一些临时变量添加到自动释放池中，统一回收释放，当自动释放池销毁时，池里面的所有对象都会调用一次release，也就是计数器会减1，但是自动释放池被销毁了，里面的对象并不一定会被销毁。使用自动释放池时要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要把大量循环放在autoreleasepool中，这样会造成内存峰值上升，因为里面创建的对象要等释放池销毁了才能释放，这种情况应该手动管理内存。&lt;/li&gt;
&lt;li&gt;尽量避免大内存使用该方法，对于这种延迟释放机制，尽量少用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果 someArray 里的元素非常多&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; someArray)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 或者在每次遍历里都创建了大量的临时变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;selector&quot;&gt;&lt;a href=&quot;#selector&quot; class=&quot;headerlink&quot; title=&quot;@selector&quot;&gt;&lt;/a&gt;@selector&lt;/h2&gt;&lt;p&gt;简而言之，@selector()就是取类方法的编号,他的行为基本可以等同C语言的中函数指针,只不过C语言中，可以把函数名直接赋给一个函数指针，而Objective-C的类不能直接应用函数指针，这样只能做一个@selector语法来取,它的结果是一个SEL类型。官方文档在&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Selector.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天在网上看了一篇讲Objective-C关键字的文章，发现自己有一些关键字几乎没有用过，因此在此写文记录一下学习心得。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Objective-C" scheme="zhangfei.tk/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Swift语法学习Tips</title>
    <link href="zhangfei.tk/2015/07/21/Swift%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0Tips/"/>
    <id>zhangfei.tk/2015/07/21/Swift语法学习Tips/</id>
    <published>2015-07-21T03:11:11.000Z</published>
    <updated>2016-03-23T05:01:39.000Z</updated>
    
    <content type="html">&lt;p&gt;Swift是苹果推出一门新语言，具有现代各种语言的特性，具有简洁，简单，快速的特点，是一门值得学习的语言。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.声明，常量声明用&lt;code&gt;let&lt;/code&gt;,变量声明用&lt;code&gt;var&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;xiaofei&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//常量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;20122199&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;//变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;2.类型标注，说明声明的常量或者变量是什么类型,在后面加上一个冒号和空格，然后加上类型名称。如果不写标注，编译器会根据初始值自动推断类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;xiaofei&quot;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;//String类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num: &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;20122199&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;//Double类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;3.字符串插值，将其他类型的常量或变量转为字符串类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;xiaofei&#39;s num is \(num)&quot;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;//打印结果为：xiaofei&#39;s num is 20122199&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;4.类型转换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; three:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;//three是Int类型的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; otherThree = &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;(three)  &lt;span class=&quot;comment&quot;&gt;//otherThree是Double类型的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;5.类型别名，给类型起一个&lt;code&gt;外号&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typealias&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyInt&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;//现在你就可以用MyInt当做Int使用了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;6.元组是一个可以把多个值组合成一个复合值的类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; http404Error = (&lt;span class=&quot;number&quot;&gt;404&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;Not Found&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;7.可选类型，可选类型的意思是声明为这个类型要么有值，要么为ni.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; serverResponseCode: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;? = &lt;span class=&quot;number&quot;&gt;404&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//如果serverResponseCode没有给它初始值的话，它的值就为nil了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;8.&lt;code&gt;nil&lt;/code&gt;表示没有值，不能用于非可选类型的常量和变量。&lt;/p&gt;
&lt;p&gt;9.如果确定了一个可选类型一定有值，就可以用隐式解析可选类型避免不必要的判断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; assumedString: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;! = &lt;span class=&quot;string&quot;&gt;&quot;An implicitly unwrapped optional string&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;10.隐式解析可选类型和可选类型的区别：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; possibleString: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;? = &lt;span class=&quot;string&quot;&gt;&quot;xiaofei&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(possibleString)  &lt;span class=&quot;comment&quot;&gt;//Option(&quot;xiaofei”)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(possibleString!) &lt;span class=&quot;comment&quot;&gt;//&quot;xiaofei&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; assumeString: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;! = &lt;span class=&quot;string&quot;&gt;&quot;xiaofei&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(possibleString)  &lt;span class=&quot;comment&quot;&gt;//&quot;xiaofei&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;11.如果一个流量之后可能变成nil的话就不要使用隐式解析可选类型，这样会引起异常。&lt;/p&gt;
&lt;p&gt;12.用全局函数&lt;code&gt;assert&lt;/code&gt;来写一个断言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; age = -&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;assert&lt;/span&gt;(age &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;这个断言被触发是由于age不符合要求，它小于0了！&quot;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;//程序运行时这个断言会被触发。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;13.Swift中允许对浮点数进行求余&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; % &lt;span class=&quot;number&quot;&gt;2.5&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;//等于0.5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;14.空合运算符是用来判断可选类型的，如果这个可选类型没有值就给一个默认值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a ?? b  &lt;span class=&quot;comment&quot;&gt;//如果可选类型a的值为nil，那么就会把b的值赋给a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;15.区间运算符，&lt;code&gt;a...b&lt;/code&gt;(包括a和b),&lt;code&gt;a..&amp;lt;b&lt;/code&gt;(包括a但是不包括b)&lt;br&gt;16.可以使用&lt;code&gt;+&lt;/code&gt;来拼接字符串&lt;br&gt;17.全局函数&lt;code&gt;count(_:)&lt;/code&gt;来计算字符串的字符数量&lt;br&gt;18.数组和字典的数据类型必须明确&lt;br&gt;19.集合是用来存储相同类型,没有顺序，一个元素值能存在一个的类型&lt;br&gt;20.Swift中&lt;code&gt;switch&lt;/code&gt;匹配到&lt;code&gt;case&lt;/code&gt;分支执行完该分支后就不会往下执行了（C语言中如果不写break就会执行下一个case,OC也一样）&lt;br&gt;21.如果需要使用C语言的‘贯穿’，只需要在加一个&lt;code&gt;fallthrough&lt;/code&gt;即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; integerToDescribe = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; description = &lt;span class=&quot;string&quot;&gt;&quot;The number \(integerToDescribe) is&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; integerToDescribe &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    description += &lt;span class=&quot;string&quot;&gt;&quot; a prime number, and also&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;fallthrough&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    description += &lt;span class=&quot;string&quot;&gt;&quot; an integer.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(description)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出 &quot;The number 5 is a prime number, and also an integer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;22.Swift中函数的定义形式：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//func为定义函数的关键字，sayHello为函数名，参数为personName和time,其类型都为String，返回一个String的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(personName: String,time:String)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; greeting = &lt;span class=&quot;string&quot;&gt;&quot;Hello, &quot;&lt;/span&gt; + personName + &lt;span class=&quot;string&quot;&gt;&quot;!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; greeting&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;23.Swift函数的调用通C语言和java,不在同OC中用中括号了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sayHello(&lt;span class=&quot;string&quot;&gt;&quot;xiaoei&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;night&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;24.可以用元组让多个值作为一个复合值从函数中返回，达到函数返回多个值的目的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;someInform&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;-&amp;gt;(name:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,age:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;xiaofei&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;25.函数的外部参数名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;someInform2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(yourName name:String, yourAge age:String)&lt;/span&gt;&lt;/span&gt;-&amp;gt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name + &lt;span class=&quot;string&quot;&gt;&quot; is &quot;&lt;/span&gt; + age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(someInform2(yourName: &lt;span class=&quot;string&quot;&gt;&quot;xiaofei&quot;&lt;/span&gt;, yourAge: &lt;span class=&quot;string&quot;&gt;&quot;22&quot;&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;//xiaofei is 22&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//如果想简写外部参数名，比如和参数名一样，直接在参数名前面加一个#就OK了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;someInform3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(#yourName:String, #yourAge:String)&lt;/span&gt;&lt;/span&gt;-&amp;gt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; yourName + &lt;span class=&quot;string&quot;&gt;&quot; is &quot;&lt;/span&gt; + yourAge;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(someInform3(yourName: &lt;span class=&quot;string&quot;&gt;&quot;xiaofei&quot;&lt;/span&gt;, yourAge: &lt;span class=&quot;string&quot;&gt;&quot;22&quot;&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;//xiaofei is 22&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;26.函数参数默认值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;joinTwoWords&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(string s1: String, &lt;span class=&quot;built_in&quot;&gt;toString&lt;/span&gt; s2: String, withJoiner joiner: String = &lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s1 + joiner + s2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(joinTwoWords(string: &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;toString&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;world&quot;&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;//hello,world&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;27.函数可变参数(注意：一个函数至多能有一个可变参数，而且它必须是参数表中最后的一个。这样做是为了避免函数调用时出现歧义 )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;arithmeticMean&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(numbers: Double...)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; total: &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; number &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; numbers &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        total += number&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; total / &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;(numbers.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arithmeticMean(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// returns 3.0, which is the arithmetic mean of these five numbers&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arithmeticMean(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// returns 10.0, which is the arithmetic mean of these three numbers&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;28.函数的变量参数,变量参数的意思就是可以把参数在函数内当做变量来使用，就避免了在函数内部再次定义一个变量了（吐槽一下：程序员就是懒,呵呵）,可变参数只需要在参数前面加一个&lt;code&gt;var&lt;/code&gt;即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//变量参数string在函数体内当做一个函数体内的局部变量使用了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;alignRight&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; string: String, &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;: Int, pad: Character)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; amountToPad = &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; - &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;(string)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; amountToPad &amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; padString = &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(pad)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;...amountToPad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        string = padString + string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; originalString = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; paddedString = alignRight(originalString, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;-&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// paddedString is equal to &quot;-----hello&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// originalString is still equal to &quot;hello&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;29.函数的输入输出参数，这种类型的参数可以在函数体里面修改，并且影响函数体外的变量，就是说如果函数的参数是输入输出函数，只要你传传入函数中，函数就可以改变你的值。还记得C语言中是通过&lt;code&gt;指针&lt;/code&gt;的方式来实现的吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//注意：函数的参数声明为inout之后，外部传入的时候也需要用&amp;amp;来表征该参数不怕被改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swapTwoInts&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;inout&lt;/span&gt; a: Int, &lt;span class=&quot;keyword&quot;&gt;inout&lt;/span&gt; b: Int)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; temporaryA = a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a = b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b = temporaryA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; someInt = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherInt = &lt;span class=&quot;number&quot;&gt;107&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swapTwoInts(&amp;amp;someInt, &amp;amp;anotherInt)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// prints &quot;someInt is now 107, and anotherInt is now 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;30.函数也是一种类型，对！你没有听错，可以把一个函数当做一种类型来使用（就像普通的类型一样，如Int，Double一类的类型一样）。因此就可以把函数单做参数传入另一个函数和把函数当做返回值返回了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//该函数把一个(Int, Int) -&amp;gt; Int的函数当做了printMathResult函数的参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printMathResult&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(mathFunction: &lt;span class=&quot;params&quot;&gt;(Int, Int)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, a: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, b: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Result: \(mathFunction(a, b))&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;printMathResult(addTwoInts, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// prints &quot;Result: 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//这个函数返回了一个(Int) -&amp;gt; Int类型的函数，stepBackward和stepForward是(Int) -&amp;gt; Int类型的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;chooseStepFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(backwards: Bool)&lt;/span&gt;&lt;/span&gt; -&amp;gt; (&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; backwards ? stepBackward : stepForward&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包(有点类似OC中的block)&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Swift是苹果推出一门新语言，具有现代各种语言的特性，具有简洁，简单，快速的特点，是一门值得学习的语言。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="笔记" scheme="zhangfei.tk/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Swift" scheme="zhangfei.tk/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>我在Mac上使用的工具</title>
    <link href="zhangfei.tk/2015/06/02/MacTools/"/>
    <id>zhangfei.tk/2015/06/02/MacTools/</id>
    <published>2015-06-01T16:00:00.000Z</published>
    <updated>2016-03-03T07:37:16.000Z</updated>
    
    <content type="html">&lt;p&gt;我的Mac电脑工具&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;生活相关&quot;&gt;&lt;a href=&quot;#生活相关&quot; class=&quot;headerlink&quot; title=&quot;生活相关&quot;&gt;&lt;/a&gt;生活相关&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;谷歌浏览器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Movist播放器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;射手播放器&lt;/code&gt;一款来自中国的视频播放器，本来可以在线加载好多字幕的。但是被封了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iBooks&lt;/code&gt;一款苹果自家出的阅读器，配合epub格式的电子档文件，阅读起来棒极了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;网易云音乐&lt;/code&gt;来自网易的音乐播放器，喜欢它的内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Calibre&lt;/code&gt;一款开源的电子书阅读器，支持多种格式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;爱壁纸&lt;/code&gt;一款跨平台的壁纸软件，有很多精美的壁纸。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Parallels Desktop&lt;/code&gt;Mac上最优秀的虚拟机软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIFBrewery&lt;/code&gt;一款就视频转化为gif动画的小软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RAR解压利器&lt;/code&gt;Mac上解压rar格式的文件就靠它了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Paragon NTFS for mac&lt;/code&gt;一款可以将文件写到NTFS格式硬盘的软件。有了它就不用把你的硬盘格式化了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Tunnelblick&lt;/code&gt;翻墙软件，你懂的。使用非常简单，到&lt;a href=&quot;http://130.158.6.78/cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;下载配置文件，双击打开你就可以看外面的风景了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CleanMyMac&lt;/code&gt;一款清理软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Reader&lt;/code&gt;RSS阅读器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;licecap&lt;/code&gt;一款相当不错的gif录制软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;图像相关&quot;&gt;&lt;a href=&quot;#图像相关&quot; class=&quot;headerlink&quot; title=&quot;图像相关&quot;&gt;&lt;/a&gt;图像相关&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Photoshop&lt;/code&gt;PS神器，不必多说。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Gimp&lt;/code&gt;一款开源的类似Photoshop的图像处理软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sketch&lt;/code&gt;设计APP必备神器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pixelmator&lt;/code&gt;不想用Photoshop就用它吧。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;编辑器&quot;&gt;&lt;a href=&quot;#编辑器&quot; class=&quot;headerlink&quot; title=&quot;编辑器&quot;&gt;&lt;/a&gt;编辑器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Xcode&lt;/code&gt;我认为它才是编辑神器，至少在编写iOS程序上面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sublime&lt;/code&gt;写代码非常的丝滑，结合插件要媲美IDE了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Eclipse&lt;/code&gt;配合安卓的ADT来开发安卓软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Android Studio&lt;/code&gt;谷歌自家出的安卓开发软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MacDown&lt;/code&gt;一款用markdown语法写作的编辑器。个人认为是Mac平台上最优秀的markdown编辑器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GitBook Editor&lt;/code&gt;一款写GitBook的编辑器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;开发相关&quot;&gt;&lt;a href=&quot;#开发相关&quot; class=&quot;headerlink&quot; title=&quot;开发相关&quot;&gt;&lt;/a&gt;开发相关&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Reveal&lt;/code&gt;一款配合Xcode使用的界面调试工具，非常的强大。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PaintCode&lt;/code&gt;一款将设计转化为代码的神器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Prepo&lt;/code&gt;一款制作icon的不错的软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Icon 3x free&lt;/code&gt;另一款制作icon的软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Appicon and Launchimage Maker Lite&lt;/code&gt;一款制作icon和iOS设备启动图片的软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ImageOptim&lt;/code&gt;一款压缩图片的软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GitHub&lt;/code&gt;GitHub的客户端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Jason&lt;/code&gt;一款解析Json格式文档的小工具，能把Json格式的文档以友好的方式展现出来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MindNode Pro&lt;/code&gt;一款思维导图软件，非常的好用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XMind&lt;/code&gt;另一款优秀的思维导图软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dash&lt;/code&gt;文档阅读器，里面有各种语言的文档，win和linux下类似的是zeal。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Charles&lt;/code&gt;抓包就靠它了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个下载Mac软件的好去处，&lt;a href=&quot;http://www.pc6.com/mac/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击这里&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;大家有更好的工具请留言给我。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我的Mac电脑工具&lt;br&gt;
    
    </summary>
    
      <category term="Mac" scheme="zhangfei.tk/categories/Mac/"/>
    
    
      <category term="工具" scheme="zhangfei.tk/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="zhangfei.tk/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Xcode中蓝色和黄色文件夹的区别</title>
    <link href="zhangfei.tk/2015/05/26/Xcode%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>zhangfei.tk/2015/05/26/Xcode文件夹/</id>
    <published>2015-05-26T03:11:11.000Z</published>
    <updated>2015-12-19T16:06:04.000Z</updated>
    
    <content type="html">&lt;p&gt;今天在练习使用聚合数据SDK时，发现从外面拖到项目的sdk文件夹是蓝色的，以前不是没有注意到文件夹有２个颜色，可都没太深入研究。今天心血来潮，就来研究一下它吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;在我们引入第三方库或者使用某某SDK的时候一般都是直接将文件夹拖进工程中，并且会选择以&lt;code&gt;Copy items if needed&lt;/code&gt;的方式把文件夹复制到工程中。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150527-2.png?imageView2/2/w/638/interlace/1&quot; alt=&quot;赋值应该是复制&quot; title=&quot;赋值应该是复制&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;这样做后观察文件夹会发现它会是蓝色的。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150527-3.png&quot; alt=&quot;真的不一样诶&quot; title=&quot;xcode&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;我们第一眼看到的时候都没有思考它为什么是蓝色的，只要能用就行了。可是。。。好像用不了啊！明明已经引入文件了，为什么会报错呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150527-1.png?imageView2/2/w/638/interlace/1&quot; alt=&quot;报错了&quot; title=&quot;为什么会报错呢？&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;原来要导入头文件的时候要导入全路径呀。可是这也太麻烦了吧！怎么办好呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150527-4.png?imageView2/2/w/638/interlace/1&quot; alt=&quot;全路径&quot; title=&quot;为什么要导入全路径呢？&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;还记得刚才导入文件的时候&lt;code&gt;copy items if needed&lt;/code&gt;选项下面还有选项可更改呢，试一试呗，反正试一试又不会怀孕。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150527-5.png?imageView2/2/w/638/interlace/1&quot; alt=&quot;更改选项&quot; title=&quot;更改选项&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;然后再看看工程中，刚才引入的文件夹变颜色了！&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150527-7.png&quot; alt=&quot;变颜色了&quot; title=&quot;变颜色了&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;然后在看看文件中导入的方式，可以直接用类名，不再用全路径的方式了，美哉呀！&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150527-6.png&quot; alt=&quot;美哉&quot; title=&quot;美哉&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;可这到底是为什么呢?文件夹为什么会有蓝色的区别呢？客观别着急，切听我慢慢道来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;蓝色的是folder ，黄色的是group 。folder就是文件管理器中的文件夹的概念，而group是一个分组的概念，记得在工程中新建一个“文件夹”的时候是new group，而不是new folder吧！group 一般只在你的工程中是文件夹的形式，但是在本地的目录中还是以散乱的形式放在一起的，除非你是从外部以group的形式引用进来的。记得刚才在引入的时候更改选项为Create groups以后文件夹就变为黄色了吧。这样引用进来的文件夹，你到工程源文件夹里面观察，它已经被打散了，没有了层级慨念；而folder 只能作为资源，整个引用进项目，不能编译代码，也就是说，以folder形式引用进来的文件，不能被放在complie sources列表里面。只是拷贝到工程文件夹里面，不参与编译，还有文件夹的层级概念，所以导入头文件的时候就要写全路径了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天在练习使用聚合数据SDK时，发现从外面拖到项目的sdk文件夹是蓝色的，以前不是没有注意到文件夹有２个颜色，可都没太深入研究。今天心血来潮，就来研究一下它吧！&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="iOS" scheme="zhangfei.tk/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>使用Xcode中遇到的问题</title>
    <link href="zhangfei.tk/2015/05/18/Xcode-Problem/"/>
    <id>zhangfei.tk/2015/05/18/Xcode-Problem/</id>
    <published>2015-05-17T16:00:00.000Z</published>
    <updated>2015-12-19T16:04:52.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章主要记录平时在开发过程中使用Xcode遇到的一些问题的记录，会不断更新。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1.今天在开发中，不知道是否按到什么键，Xcode界面突然变成了这样的界面，找不到工程文件了，但是打开&lt;code&gt;.xcodeproj&lt;/code&gt;文件有工程文件，就是打开&lt;code&gt;.xcworkspace&lt;/code&gt;没有，可是打开&lt;code&gt;.xcodeproj&lt;/code&gt;文件没用啊，会报错的。让人好生郁闷！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/屏幕快照 2015-05-21 下午7.59.32.png?imageView2/3/h/150&quot; alt=&quot;image&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;解决过程&lt;/strong&gt;：开始还以为是Xcode出什么大问题了，于是使用经典手段，关掉重启，没想到这办法不管用。于是开始在网上各种找，无果，恼人啦！没办法，于是自己分析，既然是文件导航栏，我猜是不是在&lt;code&gt;Navigate&lt;/code&gt;选项呢？结果不试不知道，一试吓一跳。熟悉的界面出来了。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/xcode-problem.png&quot; alt=&quot;image&quot;&gt;&lt;/center&gt;

&lt;p&gt;2.问题：在模拟器中调试程序中点击&lt;code&gt;UItextField&lt;/code&gt;输入框进行输入的时候，键盘没有弹出来，在Xcode终端打印错误：Can’t find keyplane that supports type 5 for keyboard iPhone-Portrait-PhonePad; using 1188396531_Portrait_iPhone-Complex-Pad_Default，真机测试没有问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：点击模拟器上面的菜单：Hardware-&amp;gt;Keyboard-&amp;gt;ConnectHardware Keyboard这一项不要勾选,这时候键盘就能正常显示了。但是此时就不能用电脑键盘进行输入了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要记录平时在开发过程中使用Xcode遇到的一些问题的记录，会不断更新。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="zhangfei.tk/categories/iOS/"/>
    
    
      <category term="Xcode" scheme="zhangfei.tk/tags/Xcode/"/>
    
      <category term="iOS" scheme="zhangfei.tk/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>给自己的博客注册一个免费域名</title>
    <link href="zhangfei.tk/2015/05/15/domain/"/>
    <id>zhangfei.tk/2015/05/15/domain/</id>
    <published>2015-05-15T03:11:11.000Z</published>
    <updated>2015-12-19T16:04:10.000Z</updated>
    
    <content type="html">&lt;p&gt;博客用github/gitcafe+jekyll搭建好之后，就是给自己的博客搞一个域名,对于没有money的孩子来说只有注册免费域名这一道路了。下面我就注册免费域名的经历给大家分享一下我注册免费域名并绑定到博客的经验。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1.注册免费域名，我选择的是&lt;a href=&quot;https://my.freenom.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;freenom&lt;/a&gt;，这里可以免费注册以&lt;code&gt;.tk&lt;/code&gt;,&lt;code&gt;.ga&lt;/code&gt;,&lt;code&gt;.gq&lt;/code&gt;,&lt;code&gt;.cf&lt;/code&gt;,&lt;code&gt;.ml&lt;/code&gt;结尾的域名，并且最高可以选择一年的使用时间，当然时间到了之后你也可以继续注册免费使用。注册的过程很简单，无非就是填写一下email然后确认一下之类的步骤。注册成功以后来到&lt;code&gt;My Domains&lt;/code&gt;页面。如下图，进入域名管理。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150602-4.png?imageView2/2/w/635/interlace/1&quot; alt=&quot;manage domain&quot; title=&quot;domain&quot;&gt;&lt;/center&gt;

&lt;p&gt;2.来到域名管理页面后可以查看到你的域名信息，然后进入&lt;code&gt;Manage Freenom DNS&lt;/code&gt;来管理你的域名相关的DNS设置。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150602-2.png?imageView2/2/w/635/interlace/1&quot; alt=&quot;DNS&quot; title=&quot;domain&quot;&gt;&lt;/center&gt;

&lt;p&gt;3.来到这里发现&lt;code&gt;Type&lt;/code&gt;可以添加&lt;code&gt;A记录&lt;/code&gt;以及&lt;code&gt;CNAME&lt;/code&gt;等，这里我演示的是添加&lt;code&gt;A记录&lt;/code&gt;，其实非常的简单，只需要在&lt;code&gt;Target&lt;/code&gt;处填写&lt;code&gt;gitcafe&lt;/code&gt;/&lt;code&gt;github&lt;/code&gt;的&lt;code&gt;Pages&lt;/code&gt;服务的ip即可。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150602-3.png?imageView2/2/w/635/interlace/1&quot; alt=&quot;A记录&quot; title=&quot;domain&quot;&gt;&lt;/center&gt;

&lt;p&gt;4.那么&lt;code&gt;gitcafe&lt;/code&gt;/&lt;code&gt;github&lt;/code&gt;的&lt;code&gt;Pages&lt;/code&gt;服务的ip是多少呢？来pages项目相应的主页，进入项目设置。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150602-6.png?imageView2/2/w/635/interlace/1&quot; alt=&quot;gitcafe主页&quot; title=&quot;domain&quot;&gt;&lt;/center&gt;

&lt;p&gt;5.来到项目设置首先添加你的域名，就是刚刚申请的域名。然后把提示的ip地址填写到第3步图中的&lt;code&gt;Target&lt;/code&gt;，然后&lt;code&gt;Save Changes&lt;/code&gt;即可。过一会儿你就可以用你的免费域名访问你的博客了。如果是添加&lt;code&gt;CNAME&lt;/code&gt;，需要注意的是修改项目文件的&lt;code&gt;CNAME&lt;/code&gt;文件。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/QQ20150602-7.png?imageView2/2/w/635/interlace/1&quot; alt=&quot;ip&quot; title=&quot;domain&quot;&gt;&lt;/center&gt;

&lt;p&gt;总结：注册域名尽量用自己的名字或者容易记的英文字母组合。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;博客用github/gitcafe+jekyll搭建好之后，就是给自己的博客搞一个域名,对于没有money的孩子来说只有注册免费域名这一道路了。下面我就注册免费域名的经历给大家分享一下我注册免费域名并绑定到博客的经验。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="zhangfei.tk/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="域名" scheme="zhangfei.tk/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="随笔" scheme="zhangfei.tk/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>初识Android Studio</title>
    <link href="zhangfei.tk/2015/05/11/androidStudio%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>zhangfei.tk/2015/05/11/androidStudio的介绍/</id>
    <published>2015-05-11T03:11:11.000Z</published>
    <updated>2015-12-19T16:03:05.000Z</updated>
    
    <content type="html">&lt;p&gt;Android Studio是谷歌推出的Android应用程序开发IDE，虽然现在主流还是用Eclipse来开发Android程序，但是我估计随着谷歌对Android的掌控，Android Studio会成为Android程序开发的主要工具。下面先来看看它的庐山真面目吧！&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/深度截图20150517100443.png&quot; alt=&quot;android studio&quot; title=&quot;android&quot;&gt;&lt;/center&gt;

&lt;p&gt;是不是美美哒？既然Android是源于linux,我就选择一个linux系统作为开发系统环境吧！我选用的系统是deepin 2014.3，安装Android Studio的方法是用Unubtu Make,如果不了解Unubtu Make，请自行google，下面我讲一讲大概的安装方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1.添加ppa&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make
sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.安装Ubuntu Make&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install ubuntu-make
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.安装Android Studio&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;umake android
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果一切顺利，你就可以到启动器(程序列表)中打开你安装好的Android Studio了！就会像下面那样开启你的Android Studio之旅了。但是打开以后你会遇到一些疑问。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/深度截图20150517100150.png&quot; alt=&quot;android&quot; title=&quot;android&quot;&gt;&lt;/center&gt;


&lt;p&gt;1.第一次打开会出现如下界面，这是在下载SDK的相关组件。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/深度截图20150517100245.png&quot; alt=&quot;download&quot; title=&quot;install&quot;&gt;&lt;/center&gt;


&lt;p&gt;解决办法：耐心等待，不要以为是卡主了，我也等了好久才下载好。当然如果过分就了，就得考虑翻墙了。&lt;/p&gt;
&lt;p&gt;２．打开以后出现一下提示&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/深度截图20150513073317.png&quot; alt=&quot;tips&quot; title=&quot;tips&quot;&gt;&lt;/center&gt;


&lt;p&gt;解决办法：这是由于linux上默认安装的java环境是openjdk,所以要按照提示安装一个oracle的java环境。下面是我安装oracle的java环境办法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssudo add-apt-repository ppa:webupd8team/java
sudo apt-get update
sudo apt-get install oracle-java8-installer
sudo apt-get install oracle-java8-set-default
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.模拟器老是弹出一个说谷歌服务停止的提示框&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xiz34.com1.z0.glb.clouddn.com/深度截图20150515224050.png&quot; alt=&quot;google services&quot; title=&quot;google&quot;&gt;&lt;/center&gt;

&lt;p&gt;解决办法：在模拟器中找到Settings–&amp;gt;Apps–&amp;gt;ALL,找到Google Play Services,点击进去，DISABLED就OK了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Android Studio是谷歌推出的Android应用程序开发IDE，虽然现在主流还是用Eclipse来开发Android程序，但是我估计随着谷歌对Android的掌控，Android Studio会成为Android程序开发的主要工具。下面先来看看它的庐山真面目吧！&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="zhangfei.tk/categories/Android/"/>
    
    
      <category term="教程" scheme="zhangfei.tk/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Android" scheme="zhangfei.tk/tags/Android/"/>
    
  </entry>
  
</feed>
